import String from "std::string";

export enum TokenType {
  // Single-character tokens
  Plus,
  Minus,
  Asterisk,
  Slash,
  LeftParen,
  RightParen,
  LeftBrace,
  RightBrace,
  LeftBrack,
  RightBrack,
  Colon,
  Pipe,
  Ampersand,
  Mod,
  QuestionMark,
  At,
  Hash,
  Caret,
  Tilde,

  // One or two character tokens
  Equal,
  EqualEqual,
  Bang,
  BangEqual,
  Greater,
  GreaterEqual,
  Less,
  LessEqual,
  Or,
  And,
  Arrow,
  Increment,
  Decrement,
  AddAssign,
  SubtractAssign,
  MulAssign,
  DivAssign,
  ModAssign,
  LeftShift,
  RightShift,
  NotAssign,
  XorAssign,
  OrAssign,
  AndAssign,
  LeftShiftAssign,
  RightShiftAssign,
  DoubleColon,
  Variadic,
  Range,
  RangeInclusive,

  // Separator
  Comma,
  SemiColon,
  Dot,

  // Literals
  Int,
  Float,
  Char,
  String,
  Hex,
  Binary,

  // Types
  StringType,
  Int8Type,
  Int16Type,
  Int32Type,
  Int64Type,
  UnsignedInt8Type,
  UnsignedInt16Type,
  UnsignedInt32Type,
  UnsignedInt64Type,
  BooleanType,
  Float32Type,
  Float64Type,
  CharType,
  AtomType,
  HexType,
  BinaryType,

  // Keywords
  Static,
  Public,
  Private,
  Else,
  False,
  True,
  Function,
  For,
  In,
  Of,
  If,
  Null,
  Return,
  This,
  Self_,
  Let,
  Const,
  Mut,
  As,
  Is,
  While,
  Break,
  Enum,
  Export,
  Import,
  Type,
  From,
  Void,
  Extern,
  Continue,
  Record,
  Trait,
  Decorator,
  Namespace,
  Meta,
  Match,
  When,
  Declare,
  Inline,

  Bad,
  Identifier,
  Comment,
  MultiLineComment,
  DocComment,
  InnerDocComment,
  Whitespace,
  Eof,

  public static getKeywordFromString(key: str): Option<TokenType> {
    let value: Option<TokenType> = match (key) {
      "as" -> Option::SOME(TokenType::As),
      "atom" -> Option::SOME(TokenType::AtomType),
      "binary" -> Option::SOME(TokenType::BinaryType),
      "boolean" -> Option::SOME(TokenType::BooleanType),
      "break" -> Option::SOME(TokenType::Break),
      "char" -> Option::SOME(TokenType::CharType),
      "const" -> Option::SOME(TokenType::Const),
      "continue" -> Option::SOME(TokenType::Continue),
      "declare" -> Option::SOME(TokenType::Declare),
      "decorator" -> Option::SOME(TokenType::Decorator),
      "else" -> Option::SOME(TokenType::Else),
      "enum" -> Option::SOME(TokenType::Enum),
      "export" -> Option::SOME(TokenType::Export),
      "extern" -> Option::SOME(TokenType::Extern),
      "f32" -> Option::SOME(TokenType::Float32Type),
      "f64" -> Option::SOME(TokenType::Float64Type),
      "false" -> Option::SOME(TokenType::False),
      "for" -> Option::SOME(TokenType::For),
      "from" -> Option::SOME(TokenType::From),
      "function" -> Option::SOME(TokenType::Function),
      "hex" -> Option::SOME(TokenType::HexType),
      "i16" -> Option::SOME(TokenType::Int16Type),
      "i32" -> Option::SOME(TokenType::Int32Type),
      "i64" -> Option::SOME(TokenType::Int64Type),
      "i8" -> Option::SOME(TokenType::Int8Type),
      "if" -> Option::SOME(TokenType::If),
      "import" -> Option::SOME(TokenType::Import),
      "in" -> Option::SOME(TokenType::In),
      "inline" -> Option::SOME(TokenType::Inline),
      "is" -> Option::SOME(TokenType::Is),
      "let" -> Option::SOME(TokenType::Let),
      "match" -> Option::SOME(TokenType::Match),
      "meta" -> Option::SOME(TokenType::Meta),
      "mut" -> Option::SOME(TokenType::Mut),
      "namespace" -> Option::SOME(TokenType::Namespace),
      "null" -> Option::SOME(TokenType::Null),
      "of" -> Option::SOME(TokenType::Of),
      "private" -> Option::SOME(TokenType::Private),
      "public" -> Option::SOME(TokenType::Public),
      "record" -> Option::SOME(TokenType::Record),
      "return" -> Option::SOME(TokenType::Return),
      "static" -> Option::SOME(TokenType::Static),
      "string" -> Option::SOME(TokenType::StringType),
      "this" -> Option::SOME(TokenType::This),
      "self" -> Option::SOME(TokenType::Self_),
      "trait" -> Option::SOME(TokenType::Trait),
      "true" -> Option::SOME(TokenType::True),
      "type" -> Option::SOME(TokenType::Type),
      "u16" -> Option::SOME(TokenType::UnsignedInt16Type),
      "u32" -> Option::SOME(TokenType::UnsignedInt32Type),
      "u64" -> Option::SOME(TokenType::UnsignedInt64Type),
      "u8" -> Option::SOME(TokenType::UnsignedInt8Type),
      "void" -> Option::SOME(TokenType::Void),
      "when" -> Option::SOME(TokenType::When),
      "while" -> Option::SOME(TokenType::While),
      _ -> Option::NONE,
    };

    return value;
  }

  public isPrimitiveTypeKeyword(&self): boolean {
    return match (self) {
      TokenType::Int8Type -> true,
      TokenType::Int16Type -> true,
      TokenType::Int32Type -> true,
      TokenType::Int64Type -> true,
      TokenType::UnsignedInt8Type -> true,
      TokenType::UnsignedInt16Type -> true,
      TokenType::UnsignedInt32Type -> true,
      TokenType::UnsignedInt64Type -> true,
      TokenType::Float32Type -> true,
      TokenType::Float64Type -> true,
      TokenType::BooleanType -> true,
      TokenType::CharType -> true,
      TokenType::AtomType -> true,
      TokenType::StringType -> true,
      _ -> false,
    };
  }

  public static getKeywords(): Vector<TokenType> {
    let mut keywords: Vector<TokenType> = Vector::init<TokenType>();

    keywords.push(TokenType::As);
    keywords.push(TokenType::AtomType);
    keywords.push(TokenType::BinaryType);
    keywords.push(TokenType::BooleanType);
    keywords.push(TokenType::Break);
    keywords.push(TokenType::CharType);
    keywords.push(TokenType::Const);
    keywords.push(TokenType::Continue);
    keywords.push(TokenType::Declare);
    keywords.push(TokenType::Decorator);
    keywords.push(TokenType::Else);
    keywords.push(TokenType::Enum);
    keywords.push(TokenType::Export);
    keywords.push(TokenType::Extern);
    keywords.push(TokenType::False);
    keywords.push(TokenType::Float32Type);
    keywords.push(TokenType::Float64Type);
    keywords.push(TokenType::For);
    keywords.push(TokenType::From);
    keywords.push(TokenType::Function);
    keywords.push(TokenType::HexType);
    keywords.push(TokenType::If);
    keywords.push(TokenType::Import);
    keywords.push(TokenType::In);
    keywords.push(TokenType::Inline);
    keywords.push(TokenType::Int16Type);
    keywords.push(TokenType::Int32Type);
    keywords.push(TokenType::Int64Type);
    keywords.push(TokenType::Int8Type);
    keywords.push(TokenType::Is);
    keywords.push(TokenType::Let);
    keywords.push(TokenType::Match);
    keywords.push(TokenType::Meta);
    keywords.push(TokenType::Mut);
    keywords.push(TokenType::Namespace);
    keywords.push(TokenType::Null);
    keywords.push(TokenType::Of);
    keywords.push(TokenType::Private);
    keywords.push(TokenType::Public);
    keywords.push(TokenType::Record);
    keywords.push(TokenType::Trait);
    keywords.push(TokenType::Return);
    keywords.push(TokenType::Self_);
    keywords.push(TokenType::This);
    keywords.push(TokenType::True);
    keywords.push(TokenType::Type);
    keywords.push(TokenType::UnsignedInt16Type);
    keywords.push(TokenType::UnsignedInt32Type);
    keywords.push(TokenType::UnsignedInt64Type);
    keywords.push(TokenType::UnsignedInt8Type);
    keywords.push(TokenType::Void);
    keywords.push(TokenType::When);
    keywords.push(TokenType::While);

    return keywords;
  }

  public name(&self): str {
    return match (self) {
      TokenType::AddAssign -> "AddAssign",
      TokenType::Ampersand -> "Ampersand",
      TokenType::And -> "And",
      TokenType::AndAssign -> "AndAssign",
      TokenType::Arrow -> "Arrow",
      TokenType::As -> "As",
      TokenType::Asterisk -> "Asterisk",
      TokenType::At -> "At",
      TokenType::AtomType -> "AtomType",
      TokenType::Bad -> "Bad",
      TokenType::Bang -> "Bang",
      TokenType::BangEqual -> "BangEqual",
      TokenType::Binary -> "Binary",
      TokenType::BinaryType -> "BinaryType",
      TokenType::BooleanType -> "BooleanType",
      TokenType::Break -> "Break",
      TokenType::Caret -> "Caret",
      TokenType::Char -> "Char",
      TokenType::CharType -> "CharType",
      TokenType::Colon -> "Colon",
      TokenType::Comma -> "Comma",
      TokenType::Comment -> "Comment",
      TokenType::Const -> "Const",
      TokenType::Continue -> "Continue",
      TokenType::Declare -> "Declare",
      TokenType::Decorator -> "Decorator",
      TokenType::Decrement -> "Decrement",
      TokenType::DivAssign -> "DivAssign",
      TokenType::DocComment -> "DocComment",
      TokenType::InnerDocComment -> "InnerDocComment",
      TokenType::Dot -> "Dot",
      TokenType::DoubleColon -> "DoubleColon",
      TokenType::Else -> "Else",
      TokenType::Enum -> "Enum",
      TokenType::Eof -> "Eof",
      TokenType::Equal -> "Equal",
      TokenType::EqualEqual -> "EqualEqual",
      TokenType::Export -> "Export",
      TokenType::Extern -> "Extern",
      TokenType::False -> "False",
      TokenType::Float -> "Float",
      TokenType::Float32Type -> "Float32Type",
      TokenType::Float64Type -> "Float64Type",
      TokenType::For -> "For",
      TokenType::From -> "From",
      TokenType::Function -> "Function",
      TokenType::Greater -> "Greater",
      TokenType::GreaterEqual -> "GreaterEqual",
      TokenType::Hash -> "Hash",
      TokenType::Hex -> "Hex",
      TokenType::HexType -> "HexType",
      TokenType::Identifier -> "Identifier",
      TokenType::If -> "If",
      TokenType::Import -> "Import",
      TokenType::In -> "In",
      TokenType::Increment -> "Increment",
      TokenType::Inline -> "Inline",
      TokenType::Int -> "Int",
      TokenType::Int16Type -> "Int16Type",
      TokenType::Int32Type -> "Int32Type",
      TokenType::Int64Type -> "Int64Type",
      TokenType::Int8Type -> "Int8Type",
      TokenType::Is -> "Is",
      TokenType::LeftBrace -> "LeftBrace",
      TokenType::LeftBrack -> "LeftBrack",
      TokenType::LeftParen -> "LeftParen",
      TokenType::LeftShift -> "LeftShift",
      TokenType::LeftShiftAssign -> "LeftShiftAssign",
      TokenType::Less -> "Less",
      TokenType::LessEqual -> "LessEqual",
      TokenType::Let -> "Let",
      TokenType::Match -> "Match",
      TokenType::Meta -> "Meta",
      TokenType::Minus -> "Minus",
      TokenType::Mod -> "Mod",
      TokenType::ModAssign -> "ModAssign",
      TokenType::MulAssign -> "MulAssign",
      TokenType::MultiLineComment -> "MultiLineComment",
      TokenType::Mut -> "Mut",
      TokenType::Namespace -> "Namespace",
      TokenType::NotAssign -> "NotAssign",
      TokenType::Null -> "Null",
      TokenType::Of -> "Of",
      TokenType::Or -> "Or",
      TokenType::OrAssign -> "OrAssign",
      TokenType::Pipe -> "Pipe",
      TokenType::Plus -> "Plus",
      TokenType::Private -> "Private",
      TokenType::Public -> "Public",
      TokenType::QuestionMark -> "QuestionMark",
      TokenType::Range -> "Range",
      TokenType::RangeInclusive -> "RangeInclusive",
      TokenType::Record -> "Record",
      TokenType::Return -> "Return",
      TokenType::RightBrace -> "RightBrace",
      TokenType::RightBrack -> "RightBrack",
      TokenType::RightParen -> "RightParen",
      TokenType::RightShift -> "RightShift",
      TokenType::RightShiftAssign -> "RightShiftAssign",
      TokenType::SemiColon -> "SemiColon",
      TokenType::Slash -> "Slash",
      TokenType::Static -> "Static",
      TokenType::String -> "String",
      TokenType::StringType -> "StringType",
      TokenType::SubtractAssign -> "SubtractAssign",
      TokenType::Self_ -> "Self",
      TokenType::This -> "This",
      TokenType::Tilde -> "Tilde",
      TokenType::Trait -> "Trait",
      TokenType::True -> "True",
      TokenType::Type -> "Type",
      TokenType::UnsignedInt16Type -> "UnsignedInt16Type",
      TokenType::UnsignedInt32Type -> "UnsignedInt32Type",
      TokenType::UnsignedInt64Type -> "UnsignedInt64Type",
      TokenType::UnsignedInt8Type -> "UnsignedInt8Type",
      TokenType::Variadic -> "Variadic",
      TokenType::Void -> "Void",
      TokenType::When -> "When",
      TokenType::While -> "While",
      TokenType::Whitespace -> "Whitespace",
      TokenType::XorAssign -> "XorAssign",
    };
  }
}

export record Span {
  start: u64;
  end: u64;

  public static init(): Span {
    return Span {
      start: 0,
      end: 0,
    };
  }

  public static init(start: u64, end: u64): Span {
    return Span {
      start: start,
      end: end,
    };
  }

  public toString(&self): String {
    let mut value: String = String::create("[");
    let startStr: String = String::create(self.start);
    let endStr: String = String::create(self.end);
    value = value.concat(&startStr);
    let comma: String = String::create(", ");
    value = value.concat(&comma);
    value = value.concat(&endStr);
    let bracket: String = String::create("]");
    value = value.concat(&bracket);

    return value;
  }

}

export enum LiteralValue {
  Int32(i32),
  Float64(f64),
  Char(char),
  String(str),
  Boolean(boolean),
  Hex(str),
  Binary(str),
  Null,
}

export record Token {
  type_: TokenType;
  lexeme: str;
  span: Span;

  public static init(): Token {
    return Token {
      type_: TokenType::Eof,
      lexeme: "",
      span: Span::init(),
    };
  }

  public static init(type_: TokenType, lexeme: str, span: Span): Token {
    return Token {
      type_: type_,
      lexeme: lexeme,
      span: span,
    };
  }

  public toString(&self): String {
    let mut value: String = String::create("(token type: ");
    let name: String = String::create(self.type_.name());
    value = value.concat(&name);
    let lexLabel: String = String::create(" lexeme: ");
    value = value.concat(&lexLabel);
    let lex: String = String::create(self.lexeme);
    value = value.concat(&lex);
    let spanLabel: String = String::create(" span: ");
    value = value.concat(&spanLabel);
    let spanStr: String = self.span.toString();
    value = value.concat(&spanStr);
    let close: String = String::create(")");
    value = value.concat(&close);

    return value;
  }

  public typeName(&self): str {
    return self.type_.name();
  }

  public toLiteralValue(&self): LiteralValue {
    return match (self.type_) {
      TokenType::Int -> LiteralValue::Int32(0),
      TokenType::Float -> LiteralValue::Float64(0.0),
      TokenType::Char -> LiteralValue::Char('\0'),
      TokenType::String -> LiteralValue::String(self.lexeme),
      TokenType::False -> LiteralValue::Boolean(false),
      TokenType::True -> LiteralValue::Boolean(true),
      TokenType::Hex -> LiteralValue::Hex(self.lexeme),
      TokenType::Binary -> LiteralValue::Binary(self.lexeme),
      _ -> LiteralValue::Null,
    };
  }
}

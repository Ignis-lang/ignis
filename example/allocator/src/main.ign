/**
 * Memory Allocators Test
 *
 * This test demonstrates and validates both HeapAllocator and ArenaAllocator
 * implementations. It allocates memory, writes values, checks alignment,
 * deallocates, and observes heap growth.
 */

import HeapAllocator, SearchMode from "./heap_allocator";
import ArenaAllocator from "./arena_allocator";
import Layout, Align from "std::memory";
import Io from "std::io";
import String from "std::string";
import LibC from "std::libc";

/// Prints the current program break (heap end address).
function printProgramBreak(label: str): void {
  let brk: *mut u8 = LibC::sbrk(0);
  let labelStr: String = String::create(label);
  let sep: String = String::create(": ");
  let val: String = String::create(brk as u64);
  let msg: String = labelStr.concat(&sep);
  let msg2: String = msg.concat(&val);
  Io::println(msg2);
}

/// Prints a test header.
function printHeader(title: str): void {
  let empty: String = String::create("");
  let bar: String = String::create("========================================");
  let titleStr: String = String::create(title);
  Io::println(empty);
  Io::println(bar.clone());
  Io::println(titleStr);
  Io::println(bar);
}

/// Prints a sub-section.
function printSection(title: str): void {
  let empty: String = String::create("");
  let prefix: String = String::create("--- ");
  let suffix: String = String::create(" ---");
  let titleStr: String = String::create(title);
  let line: String = prefix.concat(&titleStr);
  let line2: String = line.concat(&suffix);
  Io::println(empty);
  Io::println(line2);
}

/// Prints OK or FAIL based on condition.
function check(name: str, condition: boolean): void {
  let indent: String = String::create("  ");
  let nameStr: String = String::create(name);
  let sep: String = String::create(": ");
  Io::print(indent);
  Io::print(nameStr);
  Io::print(sep);
  if (condition) {
    Io::println(String::create("OK"));
  } else {
    Io::println(String::create("FAIL"));
  }
}

/// Prints arena statistics.
function printArenaStats(arena: &ArenaAllocator): void {
  let capLabel: String = String::create("  Capacity: ");
  let capVal: String = String::create(arena.capacity());
  Io::print(capLabel);
  Io::println(capVal);

  let usedLabel: String = String::create("  Used: ");
  let usedVal: String = String::create(arena.used());
  Io::print(usedLabel);
  Io::println(usedVal);

  let availLabel: String = String::create("  Available: ");
  let availVal: String = String::create(arena.available());
  Io::print(availLabel);
  Io::println(availVal);
}

function testHeapAllocator(): void {
  printHeader("Heap Allocator Test");

  // Show initial program break
  printProgramBreak("Initial program break");

  // Create allocator
  let mut allocator: HeapAllocator = HeapAllocator::init();

  printSection("Test 1: Allocate u32");
  let layoutU32: Layout = Layout::init<u32>();

  let sizeLabel: String = String::create("  Layout size: ");
  let sizeVal: String = String::create(layoutU32.size());
  Io::print(sizeLabel);
  Io::println(sizeVal);

  let alignLabel: String = String::create("  Layout align: ");
  let alignVal: String = String::create(layoutU32.align());
  Io::print(alignLabel);
  Io::println(alignVal);

  let ptrU32: *mut u8 = allocator.allocate(layoutU32);
  let allocLabel: String = String::create("  Allocated at: ");
  let allocVal: String = String::create(ptrU32 as u64);
  Io::print(allocLabel);
  Io::println(allocVal);
  check("Pointer not null", ptrU32 != null);
  check("4-byte aligned", Align::isAligned(ptrU32 as u64, 4));

  // Write a value to verify memory is usable
  let u32Ptr: *mut u32 = ptrU32 as *mut u32;
  *u32Ptr = 0xDEADBEEF;
  check("Write/read u32", *u32Ptr == 0xDEADBEEF);

  printProgramBreak("After u32 allocation");

  printSection("Test 2: Allocate u8 array (12 bytes)");
  let layoutU8Array: Layout = Layout::init(12 as u64, 1 as u64);
  let ptrU8Array: *mut u8 = allocator.allocate(layoutU8Array);
  let allocLabel2: String = String::create("  Allocated at: ");
  let allocVal2: String = String::create(ptrU8Array as u64);
  Io::print(allocLabel2);
  Io::println(allocVal2);
  check("Pointer not null", ptrU8Array != null);

  // Write pattern to array
  let mut i: u64 = 0;
  while (i < 12) {
    let bytePtr: *mut u8 = (ptrU8Array as u64 + i) as *mut u8;
    *bytePtr = (i as u8) + 1;
    i = i + 1;
  }

  // Verify pattern
  let byte0: *mut u8 = ptrU8Array;
  let byte11: *mut u8 = (ptrU8Array as u64 + 11) as *mut u8;
  check("First byte correct", *byte0 == 1);
  check("Last byte correct", *byte11 == 12);

  printSection("Test 3: Allocate u64 (8-byte alignment)");
  let layoutU64: Layout = Layout::init<u64>();
  let ptrU64: *mut u8 = allocator.allocate(layoutU64);
  let allocLabel3: String = String::create("  Allocated at: ");
  let allocVal3: String = String::create(ptrU64 as u64);
  Io::print(allocLabel3);
  Io::println(allocVal3);
  check("Pointer not null", ptrU64 != null);
  check("8-byte aligned", Align::isAligned(ptrU64 as u64, 8));

  let u64Ptr: *mut u64 = ptrU64 as *mut u64;
  *u64Ptr = 0x123456789ABCDEF0;
  check("Write/read u64", *u64Ptr == 0x123456789ABCDEF0);

  printSection("Test 4: Allocate u16 array (32 bytes, 2-byte align)");
  let layoutU16Array: Layout = Layout::init(32 as u64, 2 as u64);
  let ptrU16Array: *mut u8 = allocator.allocate(layoutU16Array);
  let allocLabel4: String = String::create("  Allocated at: ");
  let allocVal4: String = String::create(ptrU16Array as u64);
  Io::print(allocLabel4);
  Io::println(allocVal4);
  check("Pointer not null", ptrU16Array != null);
  check("2-byte aligned", Align::isAligned(ptrU16Array as u64, 2));

  printProgramBreak("After 4 allocations");

  printSection("Test 5: Deallocate last allocation");
  allocator.deallocate(ptrU16Array);
  printProgramBreak("After deallocating last block");

  printSection("Test 6: Deallocate middle allocation (u8 array)");
  let note: String = String::create("  (Should only mark as free, not shrink heap)");
  Io::println(note);
  allocator.deallocate(ptrU8Array);
  printProgramBreak("After deallocating middle block");

  printSection("Test 7: Large allocation (64KB)");
  let layoutLarge: Layout = Layout::init(65536 as u64, 8 as u64);
  let reqLabel: String = String::create("  Requesting ");
  let reqVal: String = String::create(layoutLarge.size());
  let reqSuffix: String = String::create(" bytes");
  Io::print(reqLabel);
  Io::print(reqVal);
  Io::println(reqSuffix);

  let ptrLarge: *mut u8 = allocator.allocate(layoutLarge);
  let allocLabel5: String = String::create("  Allocated at: ");
  let allocVal5: String = String::create(ptrLarge as u64);
  Io::print(allocLabel5);
  Io::println(allocVal5);
  check("Pointer not null", ptrLarge != null);
  check("8-byte aligned", Align::isAligned(ptrLarge as u64, 8));

  printProgramBreak("After 64KB allocation");

  // Write to first and last byte of large block
  let firstByte: *mut u8 = ptrLarge;
  let lastByte: *mut u8 = (ptrLarge as u64 + 65535) as *mut u8;
  *firstByte = 0xAA;
  *lastByte = 0xBB;
  check("First byte of large block", *firstByte == 0xAA);
  check("Last byte of large block", *lastByte == 0xBB);

  printSection("Test 8: Deallocate large block");
  allocator.deallocate(ptrLarge);
  printProgramBreak("After deallocating 64KB block");

  printSection("Test 9: Search mode change");
  let modeMsg: String = String::create("  Changing to BestFit search mode");
  Io::println(modeMsg);
  allocator.setSearchMode(SearchMode::BestFit);
  let modeOk: String = String::create("  Search mode changed successfully");
  Io::println(modeOk);
}

function testArenaAllocator(): void {
  printHeader("Arena Allocator Test");

  printProgramBreak("Before arena creation");

  printSection("Test 1: Create arena (4KB)");
  let mut arena: ArenaAllocator = ArenaAllocator::init(4096);
  check("Arena created", arena.start != null);
  check("Arena is empty", arena.isEmpty());
  printArenaStats(&arena);

  printProgramBreak("After arena creation");

  printSection("Test 2: Allocate u64 (8-byte alignment)");
  let layoutU64: Layout = Layout::init<u64>();
  let ptrU64: *mut u8 = arena.allocate(layoutU64);
  let allocLabel: String = String::create("  Allocated at: ");
  let allocVal: String = String::create(ptrU64 as u64);
  Io::print(allocLabel);
  Io::println(allocVal);
  check("Pointer not null", ptrU64 != null);
  check("8-byte aligned", Align::isAligned(ptrU64 as u64, 8));

  let u64Ptr: *mut u64 = ptrU64 as *mut u64;
  *u64Ptr = 0xCAFEBABE12345678;
  check("Write/read u64", *u64Ptr == 0xCAFEBABE12345678);

  printArenaStats(&arena);

  printSection("Test 3: Multiple small allocations");
  let layout16: Layout = Layout::init(16 as u64, 8 as u64);

  let ptr1: *mut u8 = arena.allocate(layout16);
  let ptr2: *mut u8 = arena.allocate(layout16);
  let ptr3: *mut u8 = arena.allocate(layout16);

  check("ptr1 not null", ptr1 != null);
  check("ptr2 not null", ptr2 != null);
  check("ptr3 not null", ptr3 != null);

  // Verify allocations are contiguous (no headers between them)
  let diff1: u64 = (ptr2 as u64) - (ptr1 as u64);
  let diff2: u64 = (ptr3 as u64) - (ptr2 as u64);
  let distLabel1: String = String::create("  Distance ptr1->ptr2: ");
  let distVal1: String = String::create(diff1);
  Io::print(distLabel1);
  Io::println(distVal1);

  let distLabel2: String = String::create("  Distance ptr2->ptr3: ");
  let distVal2: String = String::create(diff2);
  Io::print(distLabel2);
  Io::println(distVal2);
  check("Contiguous allocation (16 bytes apart)", diff1 == 16 && diff2 == 16);

  printArenaStats(&arena);

  printSection("Test 4: Write to all allocations");
  // Write different values to each allocation
  let p1: *mut u64 = ptr1 as *mut u64;
  let p2: *mut u64 = ptr2 as *mut u64;
  let p3: *mut u64 = ptr3 as *mut u64;

  *p1 = 0x1111111111111111;
  *p2 = 0x2222222222222222;
  *p3 = 0x3333333333333333;

  check("ptr1 value correct", *p1 == 0x1111111111111111);
  check("ptr2 value correct", *p2 == 0x2222222222222222);
  check("ptr3 value correct", *p3 == 0x3333333333333333);

  printSection("Test 5: Allocate until near capacity");
  let usedBefore: u64 = arena.used();
  let availableBefore: u64 = arena.available();

  let usedLabel: String = String::create("  Used before: ");
  let usedVal: String = String::create(usedBefore);
  Io::print(usedLabel);
  Io::println(usedVal);

  let availLabel: String = String::create("  Available before: ");
  let availVal: String = String::create(availableBefore);
  Io::print(availLabel);
  Io::println(availVal);

  // Allocate most of remaining space
  let largeLayout: Layout = Layout::init(3000 as u64, 8 as u64);
  let ptrLarge: *mut u8 = arena.allocate(largeLayout);
  check("Large allocation succeeded", ptrLarge != null);

  printArenaStats(&arena);

  printSection("Test 6: Allocation failure (out of space)");
  let hugeLayout: Layout = Layout::init(2000 as u64, 8 as u64);
  let ptrHuge: *mut u8 = arena.allocate(hugeLayout);
  check("Allocation failed (returned null)", ptrHuge == null);

  printSection("Test 7: Reset arena");
  let resetMsg: String = String::create("  Resetting arena...");
  Io::println(resetMsg);
  arena.reset();
  check("Arena is empty after reset", arena.isEmpty());
  check("Used is 0", arena.used() == 0);
  check("Available equals capacity", arena.available() == arena.capacity());

  printArenaStats(&arena);

  printSection("Test 8: Allocate after reset");
  let ptrAfterReset: *mut u8 = arena.allocate(layoutU64);
  check("Allocation after reset succeeded", ptrAfterReset != null);

  // Should be at the same address as the first allocation
  let firstLabel: String = String::create("  First allocation was at: ");
  let firstVal: String = String::create(ptrU64 as u64);
  Io::print(firstLabel);
  Io::println(firstVal);

  let afterLabel: String = String::create("  After reset allocated at: ");
  let afterVal: String = String::create(ptrAfterReset as u64);
  Io::print(afterLabel);
  Io::println(afterVal);
  check("Same starting address", ptrAfterReset == ptrU64);

  printSection("Test 9: Destroy arena");
  printProgramBreak("Before destroy");
  arena.destroy();
  printProgramBreak("After destroy");
  check("Arena pointers are null", arena.start == null);
}

function main(): i32 {
  testHeapAllocator();
  testArenaAllocator();

  printHeader("All tests completed!");

  return 0;
}

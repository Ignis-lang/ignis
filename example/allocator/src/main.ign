/**
 * Memory Allocators Test
 *
 * This test demonstrates and validates both HeapAllocator and ArenaAllocator
 * implementations. It allocates memory, writes values, checks alignment,
 * deallocates, and observes heap growth.
 */

import HeapAllocator, SearchMode from "./heap_allocator";
import ArenaAllocator from "./arena_allocator";
import Layout, Align from "std::memory";
import Io from "std::io";
import String from "std::string";
import LibC from "std::libc";

/// Prints the current program break (heap end address).
function printProgramBreak(label: string): void {
  let brk: *mut u8 = LibC::sbrk(0);
  Io::print(label);
  Io::print(": ");
  Io::println(String::toString(brk as u64));
}

/// Prints a test header.
function printHeader(title: string): void {
  Io::println("");
  Io::println("========================================");
  Io::println(title);
  Io::println("========================================");
}

/// Prints a sub-section.
function printSection(title: string): void {
  Io::println("");
  Io::print("--- ");
  Io::print(title);
  Io::println(" ---");
}

/// Prints OK or FAIL based on condition.
function check(name: string, condition: boolean): void {
  Io::print("  ");
  Io::print(name);
  Io::print(": ");
  if (condition) {
    Io::println("OK");
  } else {
    Io::println("FAIL");
  }
}

/// Prints arena statistics.
function printArenaStats(arena: &ArenaAllocator): void {
  Io::print("  Capacity: ");
  Io::println(String::toString(arena.capacity()));
  Io::print("  Used: ");
  Io::println(String::toString(arena.used()));
  Io::print("  Available: ");
  Io::println(String::toString(arena.available()));
}

function testHeapAllocator(): void {
  printHeader("Heap Allocator Test");

  // Show initial program break
  printProgramBreak("Initial program break");

  // Create allocator
  let mut allocator: HeapAllocator = HeapAllocator::init();

  printSection("Test 1: Allocate u32");
  let layoutU32: Layout = Layout::init<u32>();
  Io::print("  Layout size: ");
  Io::println(String::toString(layoutU32.size()));
  Io::print("  Layout align: ");
  Io::println(String::toString(layoutU32.align()));

  let ptrU32: *mut u8 = allocator.allocate(layoutU32);
  Io::print("  Allocated at: ");
  Io::println(String::toString(ptrU32 as u64));
  check("Pointer not null", ptrU32 != null);
  check("4-byte aligned", Align::isAligned(ptrU32 as u64, 4));

  // Write a value to verify memory is usable
  let u32Ptr: *mut u32 = ptrU32 as *mut u32;
  *u32Ptr = 0xDEADBEEF;
  check("Write/read u32", *u32Ptr == 0xDEADBEEF);

  printProgramBreak("After u32 allocation");

  printSection("Test 2: Allocate u8 array (12 bytes)");
  let layoutU8Array: Layout = Layout::init(12 as u64, 1 as u64);
  let ptrU8Array: *mut u8 = allocator.allocate(layoutU8Array);
  Io::print("  Allocated at: ");
  Io::println(String::toString(ptrU8Array as u64));
  check("Pointer not null", ptrU8Array != null);

  // Write pattern to array
  let mut i: u64 = 0;
  while (i < 12) {
    let bytePtr: *mut u8 = (ptrU8Array as u64 + i) as *mut u8;
    *bytePtr = (i as u8) + 1;
    i = i + 1;
  }

  // Verify pattern
  let byte0: *mut u8 = ptrU8Array;
  let byte11: *mut u8 = (ptrU8Array as u64 + 11) as *mut u8;
  check("First byte correct", *byte0 == 1);
  check("Last byte correct", *byte11 == 12);

  printSection("Test 3: Allocate u64 (8-byte alignment)");
  let layoutU64: Layout = Layout::init<u64>();
  let ptrU64: *mut u8 = allocator.allocate(layoutU64);
  Io::print("  Allocated at: ");
  Io::println(String::toString(ptrU64 as u64));
  check("Pointer not null", ptrU64 != null);
  check("8-byte aligned", Align::isAligned(ptrU64 as u64, 8));

  let u64Ptr: *mut u64 = ptrU64 as *mut u64;
  *u64Ptr = 0x123456789ABCDEF0;
  check("Write/read u64", *u64Ptr == 0x123456789ABCDEF0);

  printSection("Test 4: Allocate u16 array (32 bytes, 2-byte align)");
  let layoutU16Array: Layout = Layout::init(32 as u64, 2 as u64);
  let ptrU16Array: *mut u8 = allocator.allocate(layoutU16Array);
  Io::print("  Allocated at: ");
  Io::println(String::toString(ptrU16Array as u64));
  check("Pointer not null", ptrU16Array != null);
  check("2-byte aligned", Align::isAligned(ptrU16Array as u64, 2));

  printProgramBreak("After 4 allocations");

  printSection("Test 5: Deallocate last allocation");
  allocator.deallocate(ptrU16Array);
  printProgramBreak("After deallocating last block");

  printSection("Test 6: Deallocate middle allocation (u8 array)");
  Io::println("  (Should only mark as free, not shrink heap)");
  allocator.deallocate(ptrU8Array);
  printProgramBreak("After deallocating middle block");

  printSection("Test 7: Large allocation (64KB)");
  let layoutLarge: Layout = Layout::init(65536 as u64, 8 as u64);
  Io::print("  Requesting ");
  Io::print(String::toString(layoutLarge.size()));
  Io::println(" bytes");

  let ptrLarge: *mut u8 = allocator.allocate(layoutLarge);
  Io::print("  Allocated at: ");
  Io::println(String::toString(ptrLarge as u64));
  check("Pointer not null", ptrLarge != null);
  check("8-byte aligned", Align::isAligned(ptrLarge as u64, 8));

  printProgramBreak("After 64KB allocation");

  // Write to first and last byte of large block
  let firstByte: *mut u8 = ptrLarge;
  let lastByte: *mut u8 = (ptrLarge as u64 + 65535) as *mut u8;
  *firstByte = 0xAA;
  *lastByte = 0xBB;
  check("First byte of large block", *firstByte == 0xAA);
  check("Last byte of large block", *lastByte == 0xBB);

  printSection("Test 8: Deallocate large block");
  allocator.deallocate(ptrLarge);
  printProgramBreak("After deallocating 64KB block");

  printSection("Test 9: Search mode change");
  Io::println("  Changing to BestFit search mode");
  allocator.setSearchMode(SearchMode::BestFit);
  Io::println("  Search mode changed successfully");
}

function testArenaAllocator(): void {
  printHeader("Arena Allocator Test");

  printProgramBreak("Before arena creation");

  printSection("Test 1: Create arena (4KB)");
  let mut arena: ArenaAllocator = ArenaAllocator::init(4096);
  check("Arena created", arena.start != null);
  check("Arena is empty", arena.isEmpty());
  printArenaStats(&arena);

  printProgramBreak("After arena creation");

  printSection("Test 2: Allocate u64 (8-byte alignment)");
  let layoutU64: Layout = Layout::init<u64>();
  let ptrU64: *mut u8 = arena.allocate(layoutU64);
  Io::print("  Allocated at: ");
  Io::println(String::toString(ptrU64 as u64));
  check("Pointer not null", ptrU64 != null);
  check("8-byte aligned", Align::isAligned(ptrU64 as u64, 8));

  let u64Ptr: *mut u64 = ptrU64 as *mut u64;
  *u64Ptr = 0xCAFEBABE12345678;
  check("Write/read u64", *u64Ptr == 0xCAFEBABE12345678);

  printArenaStats(&arena);

  printSection("Test 3: Multiple small allocations");
  let layout16: Layout = Layout::init(16 as u64, 8 as u64);

  let ptr1: *mut u8 = arena.allocate(layout16);
  let ptr2: *mut u8 = arena.allocate(layout16);
  let ptr3: *mut u8 = arena.allocate(layout16);

  check("ptr1 not null", ptr1 != null);
  check("ptr2 not null", ptr2 != null);
  check("ptr3 not null", ptr3 != null);

  // Verify allocations are contiguous (no headers between them)
  let diff1: u64 = (ptr2 as u64) - (ptr1 as u64);
  let diff2: u64 = (ptr3 as u64) - (ptr2 as u64);
  Io::print("  Distance ptr1->ptr2: ");
  Io::println(String::toString(diff1));
  Io::print("  Distance ptr2->ptr3: ");
  Io::println(String::toString(diff2));
  check("Contiguous allocation (16 bytes apart)", diff1 == 16 && diff2 == 16);

  printArenaStats(&arena);

  printSection("Test 4: Write to all allocations");
  // Write different values to each allocation
  let p1: *mut u64 = ptr1 as *mut u64;
  let p2: *mut u64 = ptr2 as *mut u64;
  let p3: *mut u64 = ptr3 as *mut u64;

  *p1 = 0x1111111111111111;
  *p2 = 0x2222222222222222;
  *p3 = 0x3333333333333333;

  check("ptr1 value correct", *p1 == 0x1111111111111111);
  check("ptr2 value correct", *p2 == 0x2222222222222222);
  check("ptr3 value correct", *p3 == 0x3333333333333333);

  printSection("Test 5: Allocate until near capacity");
  let usedBefore: u64 = arena.used();
  let availableBefore: u64 = arena.available();

  Io::print("  Used before: ");
  Io::println(String::toString(usedBefore));
  Io::print("  Available before: ");
  Io::println(String::toString(availableBefore));

  // Allocate most of remaining space
  let largeLayout: Layout = Layout::init(3000 as u64, 8 as u64);
  let ptrLarge: *mut u8 = arena.allocate(largeLayout);
  check("Large allocation succeeded", ptrLarge != null);

  printArenaStats(&arena);

  printSection("Test 6: Allocation failure (out of space)");
  let hugeLayout: Layout = Layout::init(2000 as u64, 8 as u64);
  let ptrHuge: *mut u8 = arena.allocate(hugeLayout);
  check("Allocation failed (returned null)", ptrHuge == null);

  printSection("Test 7: Reset arena");
  Io::println("  Resetting arena...");
  arena.reset();
  check("Arena is empty after reset", arena.isEmpty());
  check("Used is 0", arena.used() == 0);
  check("Available equals capacity", arena.available() == arena.capacity());

  printArenaStats(&arena);

  printSection("Test 8: Allocate after reset");
  let ptrAfterReset: *mut u8 = arena.allocate(layoutU64);
  check("Allocation after reset succeeded", ptrAfterReset != null);

  // Should be at the same address as the first allocation
  Io::print("  First allocation was at: ");
  Io::println(String::toString(ptrU64 as u64));
  Io::print("  After reset allocated at: ");
  Io::println(String::toString(ptrAfterReset as u64));
  check("Same starting address", ptrAfterReset == ptrU64);

  printSection("Test 9: Destroy arena");
  printProgramBreak("Before destroy");
  arena.destroy();
  printProgramBreak("After destroy");
  check("Arena pointers are null", arena.start == null);
}

function main(): i32 {
  testHeapAllocator();
  testArenaAllocator();

  printHeader("All tests completed!");

  return 0;
}

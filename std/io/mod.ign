//!
//! # I/O
//!
//! Standard output, error printing, and structured I/O error types.
//!
//! All types and functions live under the `Io` namespace.
//!
//! ## Printing
//!
//! | Function        | Stream   | Newline |
//! |-----------------|----------|---------|
//! | `Io::print`     | stdout   | No      |
//! | `Io::println`   | stdout   | Yes     |
//! | `Io::eprint`    | stderr   | No      |
//! | `Io::eprintln`  | stderr   | Yes     |
//!
//! `println` / `eprintln` support both `String` and `str` overloads:
//! - `String` variant: consumes/moves the value.
//! - `str` variant: prints directly without allocating a temporary `String`.
//!
//! ## Error Types
//!
//! | Type              | Source file | Description                                      |
//! |-------------------|------------|--------------------------------------------------|
//! | `Io::ErrorKind`   | error.ign  | Category of the I/O error (8 variants)           |
//! | `Io::IoError`     | error.ign  | Full error: kind + raw errno + strerror message  |
//!
//! ## Example
//!
//! ```ignis
//! import Io from "std::io";
//! import LibC from "std::libc";
//! import String from "std::string";
//!
//! function main(): i32 {
//!   Io::println(String::create("hello, world!"));
//!
//!   // I/O error from a failed syscall
//!   let fd: i32 = LibC::File::open("/nonexistent", LibC::File::O_RDONLY);
//!   if (fd == -1) {
//!     let err: Io::IoError = Io::IoError::lastError();
//!     // err.kind == Io::ErrorKind::NOT_FOUND
//!     // err.message == "No such file or directory"
//!     return 1;
//!   }
//!
//!   return 0;
//! }
//! ```

import String from "std::string";
import LibC from "std::libc";

import _ from "std::io::error";

/// Standard I/O namespace.
///
/// `println` and `eprintln` have overloads for both `String` and `str`.
///
/// `String` overloads consume/move the value. `str` overloads forward the
/// C string directly.
export namespace Io {
  /// Prints `message` to stdout followed by a newline (`\n`).
  ///
  /// This is the most common way to produce output. The String is
  /// moved into the function and dropped after printing.
  ///
  /// # Arguments
  ///
  /// * `message` - The String to print (consumed/moved).
  ///
  /// # Example
  ///
  /// ```ignis
  /// import Io from "std::io";
  /// import String from "std::string";
  ///
  /// Io::println(String::create("hello"));
  /// Io::println("hello from str");
  /// Io::println(String::create(42));
  /// ```
  function println(message: String): void {
    let s: str = message.toStr();
    let len: u64 = message.length();

    LibC::File::write(LibC::File::STDOUT_FILENO, s as *void, len);
    LibC::File::write(LibC::File::STDOUT_FILENO, "\n" as *void, 1);
  }

  /// Prints a `str` message to stdout followed by a newline (`\n`).
  function println(message: str): void {
    let len: u64 = LibC::String::strlen(message as *u8);

    LibC::File::write(LibC::File::STDOUT_FILENO, message as *void, len);
    LibC::File::write(LibC::File::STDOUT_FILENO, "\n" as *void, 1);
  }

  /// Prints `message` to stderr followed by a newline (`\n`).
  ///
  /// Use this for error messages, warnings, and diagnostic output
  /// that should not mix with normal stdout.
  ///
  /// # Arguments
  ///
  /// * `message` - The String to print (consumed/moved).
  ///
  /// # Example
  ///
  /// ```ignis
  /// import Io from "std::io";
  /// import String from "std::string";
  ///
  /// Io::eprintln(String::create("error: file not found"));
  /// Io::eprintln("error from str");
  /// ```
  function eprintln(message: String): void {
    let s: str = message.toStr();
    let len: u64 = message.length();

    LibC::File::write(LibC::File::STDERR_FILENO, s as *void, len);
    LibC::File::write(LibC::File::STDERR_FILENO, "\n" as *void, 1);
  }

  /// Prints a `str` message to stderr followed by a newline (`\n`).
  function eprintln(message: str): void {
    let len: u64 = LibC::String::strlen(message as *u8);

    LibC::File::write(LibC::File::STDERR_FILENO, message as *void, len);
    LibC::File::write(LibC::File::STDERR_FILENO, "\n" as *void, 1);
  }

  /// Prints `message` to stdout without a trailing newline.
  ///
  /// Useful for building up output incrementally or printing prompts.
  ///
  /// # Arguments
  ///
  /// * `message` - The String to print (consumed/moved).
  ///
  /// # Example
  ///
  /// ```ignis
  /// import Io from "std::io";
  /// import String from "std::string";
  ///
  /// Io::print(String::create("Enter name: "));
  /// ```
  function print(message: String): void {
    let s: str = message.toStr();
    let len: u64 = message.length();

    LibC::File::write(LibC::File::STDOUT_FILENO, s as *void, len);
  }

  /// Prints `message` to stderr without a trailing newline.
  ///
  /// # Arguments
  ///
  /// * `message` - The String to print (consumed/moved).
  ///
  /// # Example
  ///
  /// ```ignis
  /// import Io from "std::io";
  /// import String from "std::string";
  ///
  /// Io::eprint(String::create("warning: "));
  /// Io::eprintln(String::create("low disk space"));
  /// ```
  function eprint(message: String): void {
    let s: str = message.toStr();
    let len: u64 = message.length();

    LibC::File::write(LibC::File::STDERR_FILENO, s as *void, len);
  }
}

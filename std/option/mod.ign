//!
//! # Option Module
//!
//! Presence/absence sum type.
//!
//! `Option<S>` models values that may or may not exist.
//!
//! ## Example
//!
//! ```ignis
//! import Option from "std::option";
//!
//! function maybeName(flag: boolean): Option<str> {
//!   if (flag) {
//!     return Option::SOME("ignis");
//!   }
//!
//!   return Option::NONE;
//! }
//! ```

/// Option type that models presence (`SOME`) or absence (`NONE`).
///
/// Use this when a value may be missing and that state is expected.
///
/// # Example
///
/// ```ignis
/// import Option from "std::option";
///
/// function maybeName(flag: boolean): Option<str> {
///   if (flag) {
///     return Option::SOME("ignis");
///   }
///
///   return Option::NONE;
/// }
/// ```
export enum Option<S> {
  SOME(S),
  NONE,

  public isSome(&self): boolean {
    return match (self) {
      Option::SOME(_) -> true,
      _ -> false,
    };
  }

  /**
    * @brief Checks if the option is None.
    *
    * @return True if the option is None, false otherwise.
    */
  public isNone(&self): boolean {
    return !self.isSome();
  }

  /**
    * @brief Unwraps the value in the option.
    *
    * @return The unwrapped value of type S.
    * @throws Panic if the option is None.
    */
  public unwrap(&self): S {
    return match (self) {
      Option::SOME(s) -> s,
      Option::NONE -> @panic("Option is None"),
    };
  }

  /**
    * @brief Unwraps the value or returns a default value.
    *
    * @param defaultValue A default value to return if the option is None.
    * @return The unwrapped value or the default value.
    */
  public unwrapOr(&self, defaultValue: S): S {
    return match (self) {
      Option::SOME(s) -> s,
      Option::NONE -> defaultValue,
    };
  }
}

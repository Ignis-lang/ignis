//!
//! # Rc Module
//!
//! Reference-counted shared ownership for heap-allocated values.
//!
//! `Rc<T>` provides shared ownership of a value of type `T` allocated on the
//! heap. Cloning an `Rc` increments the reference count; dropping one
//! decrements it. When the last reference is released, the payload's
//! destructor (if any) runs and the allocation is freed.
//!
//! Rc values are **move-by-default**: assigning or passing an Rc transfers
//! ownership. Use `.clone()` to create an additional reference that shares
//! the same allocation.
//!
//! # Example
//!
//! ```ignis
//! import Rc from "std::rc";
//!
//! function main(): i32 {
//!   let a: Rc<i32> = Rc::new<i32>(42);
//!   let b: Rc<i32> = a.clone();
//!   // both `a` and `b` point to the same allocation
//!   // memory is freed when both go out of scope
//!   return 0;
//! }
//! ```

extern __rc_ffi {
  @externName("ignis_rc_alloc")
  function ignis_rc_alloc(payload_size: u64, payload_align: u64, drop_fn: (*mut u8) -> void): *mut void;

  @externName("ignis_rc_get")
  function ignis_rc_get(handle: *mut void): *mut void;

  @externName("ignis_rc_retain")
  function ignis_rc_retain(handle: *mut void): void;

  @externName("ignis_rc_release")
  function ignis_rc_release(handle: *mut void): void;

  @externName("ignis_rc_count")
  function ignis_rc_count(handle: *mut void): u32;
}

/// Reference-counted shared pointer.
///
/// Wraps an opaque handle to a heap allocation that tracks how many live
/// references exist. The payload destructor runs when the last `Rc` is dropped.
@implements(Drop, Clone)
export record Rc<T> {
  handle: *mut void;

  /// Allocates a new `Rc` with refcount 1.
  ///
  /// Copies `value` into a heap allocation and registers `@dropGlue<T>()`
  /// so the payload is destroyed when the last reference is released.
  ///
  /// # Example
  ///
  /// ```ignis
  /// let r: Rc<i32> = Rc::new<i32>(100);
  /// ```
  public static new(value: T): Rc<T> {
    let h: *mut void = __rc_ffi::ignis_rc_alloc(
      @sizeOf<T>(),
      @alignOf<T>(),
      @dropGlue<T>()
    );

    let payload: *mut void = __rc_ffi::ignis_rc_get(h);

    @write<T>(payload as *mut T, value);

    return Rc {
      handle: h
    };
  }

  /// Returns the number of live references to this allocation.
  public strongCount(&self): u32 {
    return __rc_ffi::ignis_rc_count(self.handle);
  }

  /// Returns an immutable reference to the inner value.
  public get(&self): &T {
    let payload: *mut void = __rc_ffi::ignis_rc_get(self.handle);
    return (payload as *mut T) as &T;
  }

  /// Returns a mutable pointer to the inner value if this is the only
  /// live reference (`strongCount == 1`). Returns `null` otherwise.
  ///
  /// TODO: return `Option<&mut T>` once pattern matching is available:
  /// ```ignis
  /// public getMut(&mut self): Option<&mut T> {
  ///   if (self.strongCount() == 1) {
  ///     let payload: *mut void = __rc_ffi::ignis_rc_get(self.handle);
  ///     return Option::SOME((payload as *mut T) as &mut T);
  ///   }
  ///   return Option::NONE;
  /// }
  /// ```
  public getMut(&mut self): *mut T {
    if (__rc_ffi::ignis_rc_count(self.handle) == 1) {
      let payload: *mut void = __rc_ffi::ignis_rc_get(self.handle);
      return payload as *mut T;
    }

    return 0 as *mut T;
  }

  /// Creates a new reference to the same allocation.
  ///
  /// Increments the reference count by one and returns an `Rc` that
  /// shares the same underlying value.
  clone(&self): Rc<T> {
    __rc_ffi::ignis_rc_retain(self.handle);

    return Rc {
      handle: self.handle
    };
  }

  /// Releases this reference.
  ///
  /// Decrements the reference count. If this was the last reference,
  /// the payload destructor runs and the allocation is freed.
  drop(&mut self): void {
    __rc_ffi::ignis_rc_release(self.handle);
  }
}

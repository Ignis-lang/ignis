//!
//! # Rc Module
//!
//! Reference-counted shared ownership for heap-allocated values.
//!
//! `Rc<T>` provides shared ownership of a value of type `T` allocated on the
//! heap. Cloning an `Rc` increments the reference count; dropping one
//! decrements it. When the last strong reference is released, the payload's
//! destructor runs. The allocation is freed when both strong and weak counts
//! reach zero.
//!
//! `Weak<T>` is a non-owning observer. It keeps the allocation header alive
//! so `upgrade()` can check whether the value still exists, but does not
//! prevent the payload from being destroyed.
//!
//! Both types are **move-by-default**. Use `.clone()` to share.
//!
//! ## Example
//!
//! ```ignis
//! import Rc, Weak from "std::rc";
//! import Option from "std::option";
//!
//! function main(): i32 {
//!   let a: Rc<i32> = Rc::new<i32>(42);
//!   let b: Rc<i32> = a.clone();
//!   let w: Weak<i32> = a.downgrade();
//!   let upgraded: Option<Rc<i32>> = w.upgrade(); // SOME while a or b is alive
//!   return 0;
//! }
//! ```

extern __rc_ffi {
  @externName("ignis_rc_alloc")
  function ignis_rc_alloc(payload_size: u64, payload_align: u64, drop_fn: (*mut u8) -> void): *mut void;

  @externName("ignis_rc_get")
  function ignis_rc_get(handle: *mut void): *mut void;

  @externName("ignis_rc_retain")
  function ignis_rc_retain(handle: *mut void): void;

  @externName("ignis_rc_release")
  function ignis_rc_release(handle: *mut void): void;

  @externName("ignis_rc_count")
  function ignis_rc_count(handle: *mut void): u32;

  @externName("ignis_rc_downgrade")
  function ignis_rc_downgrade(handle: *mut void): void;

  @externName("ignis_rc_upgrade")
  function ignis_rc_upgrade(handle: *mut void): *mut void;

  @externName("ignis_weak_retain")
  function ignis_weak_retain(handle: *mut void): void;

  @externName("ignis_weak_release")
  function ignis_weak_release(handle: *mut void): void;

  @externName("ignis_weak_count")
  function ignis_weak_count(handle: *mut void): u32;
}

/// Reference-counted shared pointer.
@implements(Drop, Clone)
export record Rc<T> {
  handle: *mut void;

  /// Allocates a new `Rc` with strong count 1.
  ///
  /// # Example
  ///
  /// ```ignis
  /// import Rc from "std::rc";
  ///
  /// let r: Rc<i32> = Rc::new<i32>(100);
  /// ```
  public static new(value: T): Rc<T> {
    let h: *mut void = __rc_ffi::ignis_rc_alloc(
      @sizeOf<T>(),
      @alignOf<T>(),
      @dropGlue<T>()
    );

    let payload: *mut void = __rc_ffi::ignis_rc_get(h);

    @write<T>(payload as *mut T, value);

    return Rc {
      handle: h
    };
  }

  /// Returns the number of live strong references.
  ///
  /// # Example
  ///
  /// ```ignis
  /// import Rc from "std::rc";
  ///
  /// let a: Rc<i32> = Rc::new<i32>(1);
  /// let b: Rc<i32> = a.clone();
  /// let n: u32 = a.strongCount(); // 2
  /// ```
  public strongCount(&self): u32 {
    return __rc_ffi::ignis_rc_count(self.handle);
  }

  /// Returns the number of live weak references.
  ///
  /// # Example
  ///
  /// ```ignis
  /// import Rc, Weak from "std::rc";
  ///
  /// let a: Rc<i32> = Rc::new<i32>(1);
  /// let w: Weak<i32> = a.downgrade();
  /// let n: u32 = a.weakCount(); // 1
  /// ```
  public weakCount(&self): u32 {
    return __rc_ffi::ignis_weak_count(self.handle);
  }

  /// Creates a `Weak<T>` that does not keep the value alive.
  ///
  /// # Example
  ///
  /// ```ignis
  /// import Rc, Weak from "std::rc";
  ///
  /// let a: Rc<i32> = Rc::new<i32>(42);
  /// let w: Weak<i32> = a.downgrade();
  /// ```
  public downgrade(&self): Weak<T> {
    __rc_ffi::ignis_rc_downgrade(self.handle);

    return Weak {
      handle: self.handle
    };
  }

  /// Returns an immutable reference to the inner value.
  ///
  /// # Example
  ///
  /// ```ignis
  /// import Rc from "std::rc";
  ///
  /// let a: Rc<i32> = Rc::new<i32>(42);
  /// let val: &i32 = a.get();
  /// ```
  public get(&self): &T {
    let payload: *mut void = __rc_ffi::ignis_rc_get(self.handle);
    return (payload as *mut T) as &T;
  }

  /// Returns a mutable pointer to the inner value if this `Rc` is the
  /// sole owner (`strongCount == 1`), or `NONE` otherwise.
  ///
  /// # Example
  ///
  /// ```ignis
  /// import Rc from "std::rc";
  /// import Option from "std::option";
  ///
  /// let mut a: Rc<i32> = Rc::new<i32>(10);
  /// let ptr: Option<*mut i32> = a.getMut(); // SOME (unique owner)
  /// ```
  public getMut(&mut self): Option<*mut T> {
    if (__rc_ffi::ignis_rc_count(self.handle) == 1) {
      let payload: *mut void = __rc_ffi::ignis_rc_get(self.handle);
      return Option::SOME(payload as *mut T);
    }

    return Option::NONE;
  }

  /// Increments the strong count and returns a new `Rc` sharing the allocation.
  ///
  /// # Example
  ///
  /// ```ignis
  /// import Rc from "std::rc";
  ///
  /// let a: Rc<i32> = Rc::new<i32>(1);
  /// let b: Rc<i32> = a.clone();
  /// ```
  clone(&self): Rc<T> {
    __rc_ffi::ignis_rc_retain(self.handle);

    return Rc {
      handle: self.handle
    };
  }

  /// Decrements the strong count. Runs the payload destructor when it
  /// reaches zero. Frees the allocation when both counts reach zero.
  drop(&mut self): void {
    __rc_ffi::ignis_rc_release(self.handle);
  }
}

/// Non-owning observer of an `Rc<T>` allocation.
///
/// Keeps the allocation header alive so `upgrade()` can check whether the
/// value still exists. Use `Rc::downgrade()` to create one.
@implements(Drop, Clone)
export record Weak<T> {
  handle: *mut void;

  /// Attempts to promote this weak reference to a strong `Rc<T>`.
  ///
  /// Returns `SOME(Rc<T>)` if the value is still alive (strong count > 0),
  /// or `NONE` if all strong references have been dropped.
  ///
  /// When successful, the strong count is incremented.
  ///
  /// # Example
  ///
  /// ```ignis
  /// import Rc, Weak from "std::rc";
  /// import Option from "std::option";
  ///
  /// let a: Rc<i32> = Rc::new<i32>(42);
  /// let w: Weak<i32> = a.downgrade();
  /// let upgraded: Option<Rc<i32>> = w.upgrade(); // SOME while a is alive
  /// ```
  public upgrade(&self): Option<Rc<T>> {
    let result: *mut void = __rc_ffi::ignis_rc_upgrade(self.handle);

    if (result as u64 != 0) {
      return Option::SOME(Rc { handle: result });
    }

    return Option::NONE;
  }

  /// Returns the number of live weak references.
  ///
  /// # Example
  ///
  /// ```ignis
  /// import Rc, Weak from "std::rc";
  ///
  /// let a: Rc<i32> = Rc::new<i32>(1);
  /// let w: Weak<i32> = a.downgrade();
  /// let n: u32 = w.weakCount(); // 1
  /// ```
  public weakCount(&self): u32 {
    return __rc_ffi::ignis_weak_count(self.handle);
  }

  /// Returns the number of live strong references.
  ///
  /// # Example
  ///
  /// ```ignis
  /// import Rc, Weak from "std::rc";
  ///
  /// let a: Rc<i32> = Rc::new<i32>(1);
  /// let w: Weak<i32> = a.downgrade();
  /// let n: u32 = w.strongCount(); // 1
  /// ```
  public strongCount(&self): u32 {
    return __rc_ffi::ignis_rc_count(self.handle);
  }

  /// Increments the weak count and returns a new `Weak` sharing the header.
  ///
  /// # Example
  ///
  /// ```ignis
  /// import Rc, Weak from "std::rc";
  ///
  /// let a: Rc<i32> = Rc::new<i32>(1);
  /// let w1: Weak<i32> = a.downgrade();
  /// let w2: Weak<i32> = w1.clone();
  /// ```
  clone(&self): Weak<T> {
    __rc_ffi::ignis_weak_retain(self.handle);

    return Weak {
      handle: self.handle
    };
  }

  /// Decrements the weak count. Frees the allocation when both counts
  /// reach zero.
  drop(&mut self): void {
    __rc_ffi::ignis_weak_release(self.handle);
  }
}

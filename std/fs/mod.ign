//!
//! # Filesystem
//!
//! Filesystem operations with structured error handling.
//!
//! All fallible operations return `Result<T, Io::IoError>` instead of
//! raw errno codes. Import `Io` alongside `Fs` to inspect errors.
//!
//! ## Module Tree
//!
//! ```
//! std::fs                     (this file — hub, re-exports Fs namespace)
//!   std::fs::sys::mod         (platform dispatch layer)
//!     std::fs::sys::unix      (POSIX syscall wrappers — Linux/glibc)
//! ```
//!
//! ## Sub-namespaces
//!
//! | Namespace       | Description                                |
//! |-----------------|--------------------------------------------|
//! | `Fs::Sys`       | Platform syscall wrappers (selected at compile time) |
//!
//! ## Types
//!
//! | Type                    | Description                                         |
//! |-------------------------|-----------------------------------------------------|
//! | `Fs::Sys::Stat`         | File metadata from `stat(2)` / `fstat(2)`           |
//! | `Fs::Sys::SysDirEntry`  | Single directory entry from `readdir(3)`            |
//!
//! ## Constants
//!
//! Open flags, seek modes, permission bits, and dirent type constants
//! are available under `Fs::Sys`. See `sys/unix.ign` for the full list.
//!
//! ## Platform
//!
//! Currently Linux and macOS (POSIX). The `Fs::Sys` layer is designed so
//! future targets can add sibling backend modules and the dispatch hub
//! (`sys/mod.ign`) selects at compile time via `@configFlag`.
//!
//! ## Example
//!
//! ```ignis
//! import Fs from "std::fs";
//! import Io from "std::io";
//!
//! function main(): i32 {
//!   // stat a file
//!   let result: Result<Fs::Sys::Stat, Io::IoError> =
//!     Fs::Sys::stat("/etc/hosts");
//!
//!   if result.isOk() {
//!     let st: Fs::Sys::Stat = result.unwrap();
//!     // st.size, st.mode, st.uid, st.gid, ...
//!     return 0;
//!   }
//!   return 1;
//! }
//! ```
//!
//! ```ignis
//! import Fs from "std::fs";
//! import Io from "std::io";
//!
//! function main(): i32 {
//!   // write a file
//!   let fd: Result<i32, Io::IoError> = Fs::Sys::open(
//!     "/tmp/hello.txt",
//!     Fs::Sys::O_WRONLY | Fs::Sys::O_CREAT | Fs::Sys::O_TRUNC,
//!     438,
//!   );
//!   if fd.isError() { return 1; }
//!
//!   let rawFd: i32 = fd.unwrap();
//!   let msg: *u8 = "hello\n";
//!   Fs::Sys::write(rawFd, msg as *mut void, 6);
//!   Fs::Sys::close(rawFd);
//!   return 0;
//! }
//! ```

import _ from "std::fs::sys";
import _ from "std::fs::metadata";
import _ from "std::fs::file";
import _ from "std::fs::dir";

import Io from "std::io";
import Memory from "std::memory";

export namespace Fs {
  const DEFAULT_CREATE_DIR_MODE: u32 = 493;

  /// Reads an entire file into a byte vector (4 KiB buffered reads).
  function read(path: str): Result<Vector<u8>, Io::IoError> {
    let mut file: Fs::File = Fs::File::open(path)!;
    let mut output: Vector<u8> = Vector::init<u8>();

    let bufSize: u64 = 4096;
    let buf: *mut u8 = Memory::allocateVector<u8>(bufSize);

    defer Memory::free(buf);

    while (true) {
      let count: i64 = file.read(buf as *mut void, bufSize)!;
      if (count == 0) {
        break;
      }

      let mut i: i64 = 0;
      while (i < count) {
        @integerFromPointer(buf) + i
          |> @pointerFromInteger<*mut u8>(_)
          |> @read<u8>(_)
          |> output.push();
        i += 1;
      }
    }

    return Result::OK(output);
  }

  /// Reads a full file and returns it as a String.
  function readToString(path: str): Result<String, Io::IoError> {
    let bytes: Vector<u8> = Fs::read(path)!;
    let len: u64 = bytes.length();

    let raw: *mut u8 = Memory::allocateVector<u8>(len + 1);

    defer Memory::free(raw);

    if (len > 0) {
      Memory::copy<u8>(raw, bytes.asPtr(), len);
    }

    @integerFromPointer(raw) + len
      |> @pointerFromInteger<*mut u8>(_)
      |> @write<u8>(_, 0);

    return Result::OK(String::create(raw as str));
  }

  /// Creates/truncates a file and writes all bytes from `data`.
  function write(path: str, data: *void, len: u64): Result<boolean, Io::IoError> {
    let mut file: Fs::File = Fs::File::create(path)!;
    let writeResult: i64 = file.write(data, len)!;

    return Result::OK(writeResult == len);
  }

  /// Creates/truncates a file and writes an entire String.
  function writeString(path: str, s: &String): Result<boolean, Io::IoError> {
    return Fs::write(path, s.toStr() as *void, s.length());
  }

  /// Returns true when `path` exists.
  function exists(path: str): boolean {
    let statResult: Result<Fs::Sys::Stat, Io::IoError> = Fs::Sys::stat(path);
    return statResult.isOk();
  }

  /// Reads metadata for `path`.
  function metadata(path: str): Result<Fs::Metadata, Io::IoError> {
    let stat: Fs::Sys::Stat = Fs::Sys::stat(path)!;
    return Result::OK(Fs::metadataFromStat(&stat));
  }

  /// Creates a single directory.
  function createDir(path: str, mode: u32): Result<boolean, Io::IoError> {
    return Fs::Sys::mkdir(path, mode);
  }

  /// Recursively creates directories for `path` (mkdir -p behavior).
  function createDirAll(path: str): Result<boolean, Io::IoError> {
    let pathString: String = String::create(path);
    if (pathString.length() == 0) {
      return Result::OK(true);
    }

    let mut current: String = String::new();
    let len: u64 = pathString.length();
    let rawPath: *mut u8 = pathString.toStr() as *mut u8;
    let firstByte: u8 = @read<u8>(rawPath);
    let isAbsolute: boolean = firstByte == 47;

    if (isAbsolute) {
      current.pushChar('/');
    }

    let mut segmentStart: u64 = isAbsolute ? 1 : 0;
    let mut index: u64 = segmentStart;
    while (index <= len) {
      let mut isSeparator: boolean = index == len;
      if (!isSeparator) {
        let b: u8 = @integerFromPointer(rawPath) + index
          |> @pointerFromInteger<*mut u8>(_)
          |> @read<u8>(_);
        isSeparator = b == 47;
      }

      if (isSeparator) {
        let segmentLen: u64 = index - segmentStart;
        if (segmentLen > 0) {
          let segment: String = pathString.substring(segmentStart as i64, segmentLen as i64);

          if (current.length() > 0 && !(isAbsolute && current.length() == 1)) {
            current.pushChar('/');
          }

          current.push(&segment);

          if (!Fs::exists(current.toStr())) {
            let _ = Fs::Sys::mkdir(current.toStr(), DEFAULT_CREATE_DIR_MODE)!;
          }
        }

        segmentStart = index + 1;
      }

      index += 1;
    }

    return Result::OK(true);
  }

  /// Removes a file.
  function removeFile(path: str): Result<boolean, Io::IoError> {
    return Fs::Sys::unlink(path);
  }

  /// Removes an empty directory.
  function removeDir(path: str): Result<boolean, Io::IoError> {
    return Fs::Sys::rmdir(path);
  }
}

//!
//! # File Type
//!
//! RAII wrapper around a POSIX file descriptor.
//!
//! `Fs::File` owns a file descriptor and automatically closes it when dropped.
//! Use this instead of raw `open`/`close` calls for automatic resource cleanup.
//!
//! ## Construction
//!
//! | Method | Description |
//! |--------|-------------|
//! | `File::open(path)` | Open existing file for reading |
//! | `File::create(path)` | Create/truncate file for writing |
//! | `File::openWithFlags(path, flags, mode)` | Full control over open flags |
//!
//! ## Example
//!
//! ```ignis
//! import Fs from "std::fs";
//! import Io from "std::io";
//!
//! function main(): i32 {
//!   let result: Result<Fs::File, Io::IoError> = Fs::File::open("/etc/hosts");
//!   if (result.isError()) {
//!     return 1;
//!   }
//!
//!   let mut file: Fs::File = result.unwrap();
//!
//!   let mut buf: [u8; 256] = [0; 256];
//!   let readResult: Result<i64, Io::IoError> = file.read(&mut buf as *mut void, 256);
//!
//!   return 0;
//! }
//! ```

import Io from "std::io";

export namespace Fs {
  @implements(Drop)
  record File {
    fd: i32;

    /// Opens an existing file for reading.
    public static open(path: str): Result<File, Io::IoError> {
      let result: Result<i32, Io::IoError> = Fs::Sys::Unix::open(
        path,
        Fs::Sys::Unix::O_RDONLY,
        0,
      );

      if (result.isError()) {
        return Result::ERROR(result.unwrapErr());
      }

      return Result::OK(Fs::File { fd: result.unwrap() });
    }

    /// Creates or truncates a file for writing.
    public static create(path: str): Result<Fs::File, Io::IoError> {
      let result: Result<i32, Io::IoError> = Fs::Sys::Unix::open(
        path,
        Fs::Sys::Unix::O_WRONLY | Fs::Sys::Unix::O_CREAT | Fs::Sys::Unix::O_TRUNC,
        438,
      );

      if (result.isError()) {
        return Result::ERROR(result.unwrapErr());
      }

      return Result::OK(Fs::File { fd: result.unwrap() });
    }

    /// Opens a file with full control over flags and mode.
    public static openWithFlags(path: str, flags: i32, mode: u32): Result<Fs::File, Io::IoError> {
      let result: Result<i32, Io::IoError> = Fs::Sys::Unix::open(path, flags, mode);

      if (result.isError()) {
        return Result::ERROR(result.unwrapErr());
      }

      return Result::OK(Fs::File { fd: result.unwrap() });
    }

    /// Reads up to `count` bytes into `buf`. Returns 0 on EOF.
    public read(&mut self, buf: *mut void, count: u64): Result<i64, Io::IoError> {
      return Fs::Sys::Unix::read(self.fd, buf, count);
    }

    /// Writes up to `count` bytes from `buf`.
    public write(&mut self, buf: *void, count: u64): Result<i64, Io::IoError> {
      return Fs::Sys::Unix::write(self.fd, buf as *mut void, count);
    }

    /// Repositions the file offset.
    public seek(&mut self, offset: i64, whence: i32): Result<i64, Io::IoError> {
      return Fs::Sys::Unix::lseek(self.fd, offset, whence);
    }

    /// Returns file metadata via `fstat`.
    public metadata(&self): Result<Fs::Sys::Unix::Stat, Io::IoError> {
      return Fs::Sys::Unix::fstat(self.fd);
    }

    /// Returns the raw file descriptor.
    public fd(&self): i32 {
      return self.fd;
    }

    /// Closes the file descriptor.
    drop(&mut self): void {
      if (self.fd >= 0) {
        Fs::Sys::Unix::close(self.fd);
        self.fd = -1;
      }
    }
  }
}

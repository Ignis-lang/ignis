//!
//! # Directory Iteration
//!
//! Owned iterator over directory entries with automatic cleanup.
//!
//! `Fs::ReadDir` is an owned directory iterator that wraps `DIR*` and
//! automatically calls `closedir` when dropped. Each call to `next()`
//! returns an owned `DirEntry` with copied strings.
//!
//! ## Example
//!
//! ```ignis
//! import Fs from "std::fs";
//! import Io from "std::io";
//!
//! function main(): i32 {
//!   let result: Result<Fs::ReadDir, Io::IoError> = Fs::ReadDir::open("/tmp");
//!   if (result.isError()) {
//!     return 1;
//!   }
//!
//!   let mut iter: Fs::ReadDir = result.unwrap();
//!
//!   loop {
//!     let entry: Option<Fs::DirEntry> = iter.next();
//!     if (entry.isNone()) {
//!       break;
//!     }
//!
//!     let e: Fs::DirEntry = entry.unwrap();
//!     if (e.isDir()) {
//!       Io::println(e.name);
//!     }
//!   }
//!
//!   return 0;
//! }
//! ```

import Io from "std::io";
import Path from "std::path";
import CType from "std::libc";

/// Owned directory entry.
export namespace Fs {
  record DirEntry {
    /// File name (owned).
    public name: String;

    /// Full path: baseDir + "/" + name (owned).
    public path: Path::PathBuf;

    /// Classified file type.
    public fileType: Fs::FileType;

    /// Inode number.
    public ino: u64;

    /// Returns `true` if this entry is a directory.
    public isDir(&self): boolean {
      return self.fileType == Fs::FileType::DIRECTORY;
    }

    /// Returns `true` if this entry is a regular file.
    public isFile(&self): boolean {
      return self.fileType == Fs::FileType::FILE;
    }

    /// Returns `true` if this entry is a symbolic link.
    public isSymlink(&self): boolean {
      return self.fileType == Fs::FileType::SYMLINK;
    }
  }

  /// Owned directory iterator.
  @implements(Drop)
  record ReadDir {
    dir: CType::DirPtr;
    baseDir: String;

    /// Opens a directory for iteration.
    public static open(path: str): Result<Fs::ReadDir, Io::IoError> {
      return Result::OK(Fs::ReadDir {
        dir: Fs::Sys::Unix::opendir(path)!,
        baseDir: String::create(path),
      });
    }

    /// Returns the next directory entry, or `NONE` at end of directory.
    public next(&mut self): Option<Fs::DirEntry> {
      let raw: Fs::Sys::Unix::UnixDirEntry = Fs::Sys::Unix::readdir(self.dir)!;

      let ownedName: String = String::create(raw.name);

      let base: String = self.baseDir.clone();
      let mut ownedPath: Path::PathBuf = Path::PathBuf::fromString(&base);
      ownedPath.push(ownedName.toStr());

      return Option::SOME(Fs::DirEntry {
        name: ownedName,
        path: ownedPath,
        fileType: Fs::fileTypeFromDirent(raw.fileType),
        ino: raw.ino,
      });
    }

    /// Closes the directory stream.
    drop(&mut self): void {
      if (self.dir != null) {
        Fs::Sys::Unix::closedir(self.dir);
        self.dir = null;
      }

      self.baseDir.drop();
    }
  }
}

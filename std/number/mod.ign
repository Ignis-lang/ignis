extern __number {
    function integerAbs(value: i64): u64;
    function floatAbs(value: f64): f64;

    function f32ToFixed(value: f32, digits: u32): f32;
    function f64ToFixed(value: f64, digits: u32): f64;
    function f32Round(value: f32): f32;
    function f64Round(value: f64): f64;

    function f32Ceil(value: f32): f32;
    function f64Ceil(value: f64): f64;
}

function isFloat(t: u32): boolean {
  return t == Type::TypeId::F32 || t == Type::TypeId::F64;
}

export namespace Number {
  /**
    * Returns the absolute value of the number.
    *
    * @return {u64 | f64} The absolute value.
    *
    * @example
    * ```ignis
    * let num: i32 = -42;
    * let absNum: i32 = num.abs();
    * io::println(absNum); // Output: 42
    * ```
    */
  function abs<T>(value: T): T {
    let t: u32 = typeOf(value);

    if (!isFloat(t)){
      return __number::integerAbs(value) as T;
    }

    return __number::floatAbs(value) as T;
  }
}

export namespace Float {
  /**
    * Formats the number using fixed-point notation.
    *
    * @param {u32} digits - The number of digits to appear after the decimal point.
    * @return {T} The number formatted to the specified number of digits.
    *
    * @example
    * ```ignis
    * let num: f64 = 3.14159265359;
    * let formatted: string = num.toFixed(2);
    * io::println(formatted); // Output: 3.14
    * ```
    */
  function toFixed<F>(value: F, digits: u32): F {
    let t: u32 = typeOf(value);

    if (!isFloat(t)){
      return 0.0; // TODO: Error
    }

    return t == TYPE_F32_ID ? f32ToFixed(value as f32, digits) as F : f64ToFixed(value as f64, digits) as F;
  }

  /**
   * Rounds the number to the nearest integer.
   *
   * @return {R} The rounded number.
   *
   * @example
   * ```ignis
   * let num: f64 = 3.14159265359;
   * let rounded: f64 = num.round();
   * io::println(rounded); // Output: 3
   * ```
   */
  function round<R>(value: R): R {
    let t: u32 = typeOf(value);

    if (!isFloat(t)){
      return 0.0; // TODO: Error
    }

    return t == TYPE_F32_ID ? f32Round(value as f32) as R : f64Round(value as f64) as R;
  }

  /**
   * Rounds the number down to the nearest integer.
   *
   * @return {R} The largest integer less than or equal to the given number.
   *
   * @example
   * ```ignis
   * let num: f64 = 3.14159265359;
   * let floored: f64 = num.floor();
   * io::println(floored); // Output: 3
   * ```
   */
  function floor<R>(value: R): R {
    let t: u32 = typeOf(value);

    if (!isFloat(t)){
      return 0.0; // TODO: Error
    }

    return t == TYPE_F32_ID ? f32Floor(value as f32) as R : f64Floor(value as f64) as R;
  }

  /**
   * Rounds the number up to the nearest integer.
   *
   * @return {R} The smallest integer greater than or equal to the given number.
   *
   * @example
   * ```ignis
   * let num: f64 = 3.14159265359;
   * let ceiled: f64 = num.heil();
   * io::println(ceiled); // Output: 4
   * ```
   */
  function ceil<R>(value: R): R {
    let t: u32 = typeOf(value);

    if (!isFloat(t)){
      return 0.0; // TODO: Error
    }

    return t == TYPE_F32_ID ? f32Ceil(value as f32) as R : f64Ceil(value as f64) as R;
  }
}

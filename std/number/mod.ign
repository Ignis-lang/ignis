import {
  FFIDeclarationType,
  CTypes,
  FFILanguage,
  FFIFlags,
  FFIConfig,
  FFIParam,
} from "std:ffi";
import { MutOnly } from "std:meta";
import { IgnisNumbersType, IgnisFloatType } from "std:types";

export record<T as IgnisNumbersType> Numbers {
  /**
   * Converts the numeric value to a string.
   *
   * @param {T} value - The numeric value to convert.
   * @return {string} The string representation of the numeric value.
   *
   * @example
   * ```ignis
   * let num: i32 = 42;
   * let str: string = num.toString();
   * println(str); // Output: "42"
   * ```
   */
  @FFILanguage({
    type_: FFIDeclarationType.FUNCTION,
    name: "numberToString",
    params: [
      {
        name: "value",
        type_: CTypes.VOID_POINTER,
        flags: [FFIFlags.RECEIVER, FFIFlags.REFERENCE],
        isFormatted: false,
      },
      {
        name: "type",
        type_: CTypes.VOID_POINTER,
        flags: [FFIFlags.RECEIVER_TYPE, FFIFlags.POINTER],
        isFormatted: false,
      },
    ],
    returnType: CTypes.STRING,
    file: {
      headerPath: "number/number.h",
      sourcePath: "std/number/number.c",
    }
  })
  toString(): string;

  /**
   * Returns the absolute value of the number.
   *
   * @return {u64 | f64} The absolute value.
   *
   * @example
   * ```ignis
   * let num: i32 = -42;
   * let absNum: i32 = num.abs();
   * println(absNum); // Output: 42
   * ```
   */
  @FFILanguage({
    type_: FFIDeclarationType.FUNCTION,
    name: "number_abs",
    params: [
      {
        name: "this",
        type_: CTypes.VOID_POINTER,
        flags: [FFIFlags.RECEIVER, FFIFlags.POINTER],
        isFormatted: false,
      },
      {
        name: "type_",
        type_: CTypes.VOID_POINTER,
        flags: [FFIFlags.RECEIVER_TYPE, FFIFlags.POINTER],
        isFormatted: false,
      },
    ],
    returnType: CTypes.VOID,
    file: {
      headerPath: "number/number.h",
      sourcePath: "number/number.c",
    }
  })
  abs(): u64 | f64;
}

export record<F as IgnisFloatType> Floats {
  /**
   * Formats the number using fixed-point notation.
   *
   * @param {u32} digits - The number of digits to appear after the decimal point.
   * @return {T} The number formatted to the specified number of digits.
   *
   * @example
   * ```ignis
   * let num: f64 = 3.14159265359;
   * let formatted: string = num.toFixed(2);
   * println(formatted); // Output: 3.14
   * ```
   */
  @FFILanguage({
    type_: FFIDeclarationType.FUNCTION,
    name: "number_toFixed",
    params: [
      {
        name: "this",
        type_: CTypes.VOID_POINTER,
        flags: [FFIFlags.RECEIVER],
        isFormatted: false
      },
      {
        name: "digits",
        type_: CTypes.U32,
        flags: [],
        isFormatted: false
      },
    ],
    returnType: CTypes.VOID_POINTER,
    file: {
      headerPath: "number/number.h",
      sourcePath: "number/number.c",
    }
  })
  toFixed(digits: u32): F;

  /**
   * Rounds the number to the nearest integer.
   *
   * @return {R} The rounded number.
   *
   * @example
   * ```ignis
   * let num: f64 = 3.14159265359;
   * let rounded: f64 = num.round();
   * println(rounded); // Output: 3
   * ```
   */
  @FFILanguage({
    type_: FFIDeclarationType.FUNCTION,
    name: "number_round",
    params: [
      {
        name: "this",
        type_: CTypes.VOID_POINTER,
        flags: [FFIFlags.RECEIVER],
        isFormatted: false
      }
    ],
    returnType: CTypes.VOID_POINTER,
    file: {
      headerPath: "number/number.h",
      sourcePath: "number/number.c",
    }
  })
  round<R>(): R;

  /**
   * Rounds the number down to the nearest integer.
   *
   * @return {R} The largest integer less than or equal to the given number.
   *
   * @example
   * ```ignis
   * let num: f64 = 3.14159265359;
   * let floored: f64 = num.floor();
   * println(floored); // Output: 3
   * ```
   */
  @FFILanguage({
    type_: FFIDeclarationType.FUNCTION,
    name: "number_floor",
    params: [
      {
        name: "this",
        type_: CTypes.VOID_POINTER,
        flags: [FFIFlags.RECEIVER],
        isFormatted: false
      }
    ],
    returnType: CTypes.VOID_POINTER,
    file: {
      headerPath: "number/number.h",
      sourcePath: "number/number.c",
    }
  })
  floor<R>(): R;

  /**
   * Rounds the number up to the nearest integer.
   *
   * @return {R} The smallest integer greater than or equal to the given number.
   *
   * @example
   * ```ignis
   * let num: f64 = 3.14159265359;
   * let ceiled: f64 = num.heil();
   * println(ceiled); // Output: 4
   * ```
   */
  @FFILanguage({
    type_: FFIDeclarationType.FUNCTION,
    name: "number_ceil",
    params: [
      {
        name: "this",
        type_: CTypes.VOID_POINTER,
        flags: [FFIFlags.RECEIVER],
        isFormatted: false
      }
    ],
    returnType: CTypes.VOID_POINTER,
    file: {
      headerPath: "number/number.h",
      sourcePath: "number/number.c",
    }
  })
  ceil<R>(): R;
}

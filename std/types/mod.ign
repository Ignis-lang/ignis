//!
//! # Types Module
//!
//! Core runtime type identifiers and fundamental sum types.
//!
//! ## Contents
//!
//! - `Type::TypeId`: runtime identifiers mirrored from the runtime layer
//! - `Result<T, E>`: success/error sum type
//! - `Option<S>`: presence/absence sum type
//!
//! These types are intentionally minimal and suitable for std-wide reuse.
//!
//! ## Example
//!
//! ```ignis
//! import Option, Result from "std::types";
//! import Io from "std::io";
//!
//! function maybeName(flag: boolean): Option<string> {
//!   if (flag) {
//!     return Option::SOME("ignis");
//!   }
//!
//!   return Option::NONE;
//! }
//!
//! function parseOk(): Result<i32, string> {
//!   return Result::OK(10);
//! }
//!
//! function main(): i32 {
//!   let name: Option<string> = maybeName(true);
//!   let result: Result<i32, string> = parseOk();
//!
//!   // Handle with pattern matching in user code.
//!   Io::println("types ready");
//!   return 0;
//! }
//! ```
extern __types {
    const TYPE_I8_ID: u32;
    const TYPE_I16_ID: u32;
    const TYPE_I32_ID: u32;
    const TYPE_I64_ID: u32;
    const TYPE_U8_ID: u32;
    const TYPE_U16_ID: u32;
    const TYPE_U32_ID: u32;
    const TYPE_U64_ID: u32;
    const TYPE_F32_ID: u32;
    const TYPE_F64_ID: u32;
    const TYPE_BOOL_ID: u32;
    const TYPE_CHAR_ID: u32;
    const TYPE_STRING_ID: u32;
    const TYPE_POINTER_ID: u32;
}

export namespace Type {
  /// Runtime type identifiers mirrored from the Ignis runtime.
  ///
  /// These constants are useful for diagnostics, low-level tooling and FFI
  /// integrations that need stable runtime tags.
  ///
  /// # Example
  ///
  /// ```ignis
  /// import Type from "std::types";
  ///
  /// function main(): i32 {
  ///   let id: u32 = Type::TypeId::I32;
  ///   return id as i32;
  /// }
  /// ```
  namespace TypeId {
    const I8: u32 = __types::TYPE_I8_ID;
    const I16: u32 = __types::TYPE_I16_ID;
    const I32: u32 = __types::TYPE_I32_ID;
    const I64: u32 = __types::TYPE_I64_ID;
    const U8: u32 = __types::TYPE_U8_ID;
    const U16: u32 = __types::TYPE_U16_ID;
    const U32: u32 = __types::TYPE_U32_ID;
    const U64: u32 = __types::TYPE_U64_ID;
    const F32: u32 = __types::TYPE_F32_ID;
    const F64: u32 = __types::TYPE_F64_ID;
    const BOOL: u32 = __types::TYPE_BOOL_ID;
    const CHAR: u32 = __types::TYPE_CHAR_ID;
    const STRING: u32 = __types::TYPE_STRING_ID;
    const POINTER: u32 = __types::TYPE_POINTER_ID;
  }
}

/// Result type that models either success (`OK`) or failure (`ERROR`).
///
/// Use this when an operation can fail and callers should handle both paths.
///
/// # Example
///
/// ```ignis
/// import Result from "std::types";
///
/// function parse(flag: boolean): Result<i32, string> {
///   if (flag) {
///     return Result::OK(10);
///   }
///
///   return Result::ERROR("invalid");
/// }
/// ```
export enum Result<T, E> {
  OK(T),
  ERROR(E),

  /**
   * @brief Checks if the result is OK.
   *
   * @return True if the result is OK, false otherwise.
   */
  public isOk(&self): boolean {
    return match (self) {
      Result::OK(_) -> true,
      _ -> false,
    };
  }

  /**
   * @brief Checks if the result is an error.
   *
   * @return True if the result is an error, false otherwise.
   */
  public isError(&self): boolean {
    return !self.isOk();
  }

  /**
   * @brief Unwraps the result, assuming it's OK.
   *
   * @return The unwrapped value of type T.
   * @throws Panic if the result is an error.
   */
  public unwrap(&self): T {
    return match (self) {
      Result::OK(t) -> t,
      Result::ERROR(_) -> @panic("Result is an error"),
    };
  }

  /**
   * @brief Unwraps the error result.
   *
   * @return The unwrapped error value of type E.
   * @throws Panic if the result is OK.
   */
  public unwrapErr(&self): E {
    return match (self) {
      Result::OK(_) -> @panic("Result is an OK"),
      Result::ERROR(e) -> e,
    };
  }

  /**
   * @brief Unwraps the result or returns a default value.
   *
   * @param defaultValue A default value to return if the result is an error.
   * @return The unwrapped value or the default value.
   */
  public unwrapOr(&self, defaultValue: T): T {
    return match (self) {
      Result::OK(t) -> t,
      Result::ERROR(_) -> defaultValue,
    };
  }
}

/// Option type that models presence (`SOME`) or absence (`NONE`).
///
/// Use this when a value may be missing and that state is expected.
///
/// # Example
///
/// ```ignis
/// import Option from "std::types";
///
/// function maybeName(flag: boolean): Option<string> {
///   if (flag) {
///     return Option::SOME("ignis");
///   }
///
///   return Option::NONE;
/// }
/// ```
export enum Option<S> {
  SOME(S),
  NONE,

  public isSome(&self): boolean {
    return match (self) {
      Option::SOME(_) -> true,
      _ -> false,
    };
  }

  /**
   * @brief Checks if the option is None.
   *
   * @return True if the option is None, false otherwise.
   */
  public isNone(&self): boolean {
    return !self.isSome();
  }

  /**
   * @brief Unwraps the value in the option.
   *
   * @return The unwrapped value of type S.
   * @throws Panic if the option is None.
   */
  public unwrap(&self): S {
    return match (self) {
      Option::SOME(s) -> s,
      Option::NONE -> @panic("Option is None"),
    };
  }

  /**
   * @brief Unwraps the value or returns a default value.
   *
   * @param defaultValue A default value to return if the option is None.
   * @return The unwrapped value or the default value.
   */
  public unwrapOr(&self, defaultValue: S): S {
    return match (self) {
      Option::SOME(s) -> s,
      Option::NONE -> defaultValue,
    };
  }
}

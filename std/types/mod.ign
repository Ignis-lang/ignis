extern __types {
    const TYPE_I8_ID: u32;
    const TYPE_I16_ID: u32;
    const TYPE_I32_ID: u32;
    const TYPE_I64_ID: u32;
    const TYPE_U8_ID: u32;
    const TYPE_U16_ID: u32;
    const TYPE_U32_ID: u32;
    const TYPE_U64_ID: u32;
    const TYPE_F32_ID: u32;
    const TYPE_F64_ID: u32;
    const TYPE_BOOL_ID: u32;
    const TYPE_CHAR_ID: u32;
    const TYPE_STRING_ID: u32;
    const TYPE_UNKNOWN_ID: u32;
}

export namespace Type {
  enum TypeId {
    I8 = __types::TYPE_I8_ID,
    I16 = __types::TYPE_I16_ID,
    I32 = __types::TYPE_I32_ID,
    I64 = __types::TYPE_I64_ID,
    U8 = __types::TYPE_U8_ID,
    U16 = __types::TYPE_U16_ID,
    U32 = __types::TYPE_U32_ID,
    U64 = __types::TYPE_U64_ID,
    F32 = __types::TYPE_F32_ID,
    F64 = __types::TYPE_F64_ID,
    BOOL = __types::TYPE_BOOL_ID,
    CHAR = __types::TYPE_CHAR_ID,
    STRING = __types::TYPE_STRING_ID,
  }
}


export enum Result<T, E> {
  OK(T),
  ERROR(E),

  // /**
  //  * @brief Checks if the result is OK.
  //  *
  //  * @return True if the result is OK, false otherwise.
  //  */
  // public isOk(): boolean {
  //   return match (this) {
  //     Result.OK(_) -> true,
  //     _ -> false,
  //   };
  // }

  // /**
  //  * @brief Checks if the result is an error.
  //  *
  //  * @return True if the result is an error, false otherwise.
  //  */
  // public isError(): boolean {
  //   return !this.isOk();
  // }

  // /**
  //  * @brief Unwraps the result, assuming it's OK.
  //  *
  //  * @return The unwrapped value of type T.
  //  * @throws Panic if the result is an error.
  //  */
  // public unwrap(): T {
  //   return match (this) {
  //     Result.OK(t) -> t,
  //     Result.ERROR(e) -> #Panic("Result is an error"),
  //   };
  // }

  // /**
  //  * @brief Unwraps the error result.
  //  *
  //  * @return The unwrapped error value of type E.
  //  * @throws Panic if the result is OK.
  //  */
  // public unwrapErr(): E {
  //   return match (this) {
  //     Result.OK(t) -> #Panic("Result is an OK"),
  //     Result.ERROR(e) -> e,
  //   };
  // }

  // /**
  //  * @brief Unwraps the result or returns a default value.
  //  *
  //  * @param defaultValue A default value to return if the result is an error.
  //  * @return The unwrapped value or the default value.
  //  */
  // public unwrapOr(defaultValue: T): T {
  //   return match (this) {
  //     Result.OK(t) -> t,
  //     Result.ERROR(_) -> defaultValue,
  //   };
  // }
}

export enum Option<S> {
  SOME(S),
  NONE,

  // /**
  //  * @brief Checks if the option contains a value.
  //  *
  //  * @return True if the option contains a value, false otherwise.
  //  */
  // public isSome(): boolean {
  //   return self == Option::NONE;
  // }

  // /**
  //  * @brief Checks if the option is None.
  //  *
  //  * @return True if the option is None, false otherwise.
  //  */
  // public isNone(): boolean {
  //   return !self.isSome();
  // }

  // /**
  //  * @brief Unwraps the value in the option.
  //  *
  //  * @return The unwrapped value of type S.
  //  * @throws Panic if the option is None.
  //  */
  // public unwrap(): S {
  //   if self == Option::NONE {
  //     #Panic("Option is None");
  //   }

  //   return match (this) {
  //     Option.SOME(s) -> s,
  //     Option.NONE -> #Panic("Option is None"),
  //   };
  // }

  // /**
  //  * @brief Unwraps the value or returns a default value.
  //  *
  //  * @param defaultValue A default value to return if the option is None.
  //  * @return The unwrapped value or the default value.
  //  */
  // public unwrapOr(defaultValue: S): S {
  //   return match (this) {
  //     Option.SOME(s) -> s,
  //     Option.NONE -> defaultValue,
  //   };
  // }
}

//!
//! # LibC Process
//!
//! Process control, signals, and child process management.
//!
//! ## Sub-namespaces
//!
//! | Namespace        | C Header               | Description                           |
//! |------------------|------------------------|---------------------------------------|
//! | `LibC::Process`  | `stdlib.h`, `unistd.h` | Process lifecycle, environment, IPC   |
//! | `LibC::Signals`  | `signal.h`             | `raise`, `kill`                       |
//! | `LibC::Wait`     | `sys/wait.h`           | `wait`, `waitpid`                     |
//!
//! ## Constants
//!
//! | Namespace        | Constant         | Description                       |
//! |------------------|------------------|-----------------------------------|
//! | `LibC::Process`  | `EXIT_SUCCESS`   | Successful exit status            |
//! | `LibC::Process`  | `EXIT_FAILURE`   | Failure exit status               |
//! | `LibC::Signals`  | `SIGINT`         | Interrupt from keyboard (Ctrl-C)  |
//! | `LibC::Signals`  | `SIGKILL`        | Kill signal (cannot be caught)    |
//! | `LibC::Signals`  | `SIGSEGV`        | Segmentation fault                |
//! | `LibC::Signals`  | `SIGTERM`        | Termination signal                |
//!
//! ## Example
//!
//! ```ignis
//! import LibC, CType from "std::libc";
//!
//! function main(): i32 {
//!   let pid: CType::PidT = LibC::Process::getpid();
//!   let home: CType::CStr = LibC::Process::getenv("HOME");
//!
//!   if home == null {
//!     LibC::Process::exit(LibC::Process::EXIT_FAILURE);
//!   }
//!
//!   return 0;
//! }
//! ```

import CType from "./primitives";

extern __process {
  const EXIT_SUCCESS: CType::CInt;
  const EXIT_FAILURE: CType::CInt;

  function exit(status: CType::CInt): void;
  function abort(): void;
  function _exit(status: CType::CInt): void;
  function system(command: CType::CConstStr): CType::CInt;
  function getenv(name: CType::CConstStr): CType::CStr;
}

@configFlag(@platform("linux") || @platform("macos"))
extern __unistd_proc {
  function getpid(): CType::PidT;
  function getppid(): CType::PidT;
  function getuid(): CType::UidT;
  function getgid(): CType::GidT;
  function sleep(seconds: CType::CUInt): CType::CUInt;
  function usleep(usec: CType::CUInt): CType::CInt;
  function fork(): CType::PidT;
  function pipe(pipefd: *mut CType::CInt): CType::CInt;
}

@configFlag(@platform("linux") || @platform("macos"))
extern __signal {
  const SIGINT: CType::CInt;
  const SIGKILL: CType::CInt;
  const SIGSEGV: CType::CInt;
  const SIGTERM: CType::CInt;

  function raise(sig: CType::CInt): CType::CInt;
  function kill(pid: CType::PidT, sig: CType::CInt): CType::CInt;
}

@configFlag(@platform("linux") || @platform("macos"))
extern __wait {
  function wait(wstatus: *mut CType::CInt): CType::PidT;
  function waitpid(pid: CType::PidT, wstatus: *mut CType::CInt, options: CType::CInt): CType::PidT;
}

/// Process control (stdlib.h, unistd.h)
namespace LibC::Process {
  /// Successful exit status.
  const EXIT_SUCCESS: CType::CInt = __process::EXIT_SUCCESS;

  /// Failure exit status.
  const EXIT_FAILURE: CType::CInt = __process::EXIT_FAILURE;

  /// Terminates the process with `status`. Does not return.
  function exit(status: CType::CInt): void { __process::exit(status); }

  /// Terminates the process abnormally. Does not return.
  function abort(): void { __process::abort(); }

  /// Terminates the process immediately without running atexit handlers.
  function _exit(status: CType::CInt): void { __process::_exit(status); }

  /// Executes `command` via the system shell. Returns the exit status.
  function system(command: CType::CConstStr): CType::CInt { return __process::system(command); }

  /// Returns the value of environment variable `name`, or null if unset.
  function getenv(name: CType::CConstStr): CType::CStr { return __process::getenv(name); }

  /// Returns the process ID of the calling process.
  @configFlag(@platform("linux") || @platform("macos"))
  function getpid(): CType::PidT { return __unistd_proc::getpid(); }

  /// Returns the parent process ID.
  @configFlag(@platform("linux") || @platform("macos"))
  function getppid(): CType::PidT { return __unistd_proc::getppid(); }

  /// Returns the real user ID of the calling process.
  @configFlag(@platform("linux") || @platform("macos"))
  function getuid(): CType::UidT { return __unistd_proc::getuid(); }

  /// Returns the real group ID of the calling process.
  @configFlag(@platform("linux") || @platform("macos"))
  function getgid(): CType::GidT { return __unistd_proc::getgid(); }

  /// Suspends execution for `seconds` seconds.
  ///
  /// Returns 0 on success, or the remaining seconds if interrupted.
  @configFlag(@platform("linux") || @platform("macos"))
  function sleep(seconds: CType::CUInt): CType::CUInt { return __unistd_proc::sleep(seconds); }

  /// Suspends execution for `usec` microseconds.
  @configFlag(@platform("linux") || @platform("macos"))
  function usleep(usec: CType::CUInt): CType::CInt { return __unistd_proc::usleep(usec); }

  /// Creates a new process by duplicating the calling process.
  ///
  /// Returns the child PID to the parent, 0 to the child, or -1 on error.
  @configFlag(@platform("linux") || @platform("macos"))
  function fork(): CType::PidT { return __unistd_proc::fork(); }

  /// Creates a unidirectional pipe. `pipefd[0]` is the read end,
  /// `pipefd[1]` is the write end.
  @configFlag(@platform("linux") || @platform("macos"))
  function pipe(pipefd: *mut CType::CInt): CType::CInt { return __unistd_proc::pipe(pipefd); }
}

/// Signals (signal.h) — POSIX only.
@configFlag(@platform("linux") || @platform("macos"))
namespace LibC::Signals {
  /// Interrupt from keyboard (Ctrl-C).
  const SIGINT: CType::CInt = __signal::SIGINT;

  /// Kill signal (cannot be caught).
  const SIGKILL: CType::CInt = __signal::SIGKILL;

  /// Segmentation fault.
  const SIGSEGV: CType::CInt = __signal::SIGSEGV;

  /// Termination signal.
  const SIGTERM: CType::CInt = __signal::SIGTERM;

  /// Sends signal `sig` to the calling process.
  function raise(sig: CType::CInt): CType::CInt { return __signal::raise(sig); }

  /// Sends signal `sig` to process `pid`.
  function kill(pid: CType::PidT, sig: CType::CInt): CType::CInt { return __signal::kill(pid, sig); }
}

/// Wait (sys/wait.h) — POSIX only.
@configFlag(@platform("linux") || @platform("macos"))
namespace LibC::Wait {
  /// Waits for any child process to change state.
  ///
  /// Stores the status in `wstatus`. Returns the child PID.
  function wait(wstatus: *mut CType::CInt): CType::PidT { return __wait::wait(wstatus); }

  /// Waits for a specific child process `pid` to change state.
  ///
  /// `options` can be 0 or a combination of `WNOHANG`/`WUNTRACED`.
  function waitpid(pid: CType::PidT, wstatus: *mut CType::CInt, options: CType::CInt): CType::PidT { return __wait::waitpid(pid, wstatus, options); }
}

// ===========================================================================
// Windows — kernel32 process functions
// ===========================================================================

@configFlag(@platform("windows"))
extern __kernel32_proc {
  @externName("GetCurrentProcessId")
  function getCurrentProcessId(): CType::DWord;

  @externName("ExitProcess")
  function exitProcess(uExitCode: CType::CUInt): void;

  @externName("Sleep")
  function sleep(dwMilliseconds: CType::DWord): void;

  @externName("GetEnvironmentVariableA")
  function getEnvironmentVariable(lpName: CType::LpcStr, lpBuffer: CType::LpStr, nSize: CType::DWord): CType::DWord;
}

/// Win32 process functions — Windows only.
@configFlag(@platform("windows"))
namespace LibC::WinProcess {
  /// Returns the current process ID.
  function getCurrentProcessId(): CType::DWord { return __kernel32_proc::getCurrentProcessId(); }

  /// Terminates the current process. Does not return.
  function exitProcess(exitCode: CType::CUInt): void { __kernel32_proc::exitProcess(exitCode); }

  /// Suspends execution for `milliseconds` milliseconds.
  function sleep(milliseconds: CType::DWord): void { __kernel32_proc::sleep(milliseconds); }

  /// Retrieves an environment variable into `buffer`.
  ///
  /// Returns the number of characters written (excluding NUL), or 0 on failure.
  function getEnvironmentVariable(name: CType::LpcStr, buffer: CType::LpStr, size: CType::DWord): CType::DWord {
    return __kernel32_proc::getEnvironmentVariable(name, buffer, size);
  }
}

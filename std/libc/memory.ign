//!
//! # LibC Memory
//!
//! Memory allocation, byte-level operations, and virtual memory management.
//!
//! ## Sub-namespaces
//!
//! | Namespace                | C Header              | Description                                |
//! |--------------------------|-----------------------|--------------------------------------------|
//! | `LibC::Allocator`        | `stdlib.h`            | `malloc`, `calloc`, `realloc`, `free`      |
//! | `LibC::MemoryOperations` | `string.h`            | `memcpy`, `memmove`, `memset`, `memcmp`    |
//! | `LibC::Memory`           | `sys/mman.h`, `unistd.h` | `mmap`, `munmap`, `mprotect`, `sbrk`, `brk` |
//!
//! ## Constants (`LibC::Memory`)
//!
//! | Constant         | Description                          |
//! |------------------|--------------------------------------|
//! | `PROT_NONE`      | No access permitted                  |
//! | `PROT_READ`      | Pages may be read                    |
//! | `PROT_WRITE`     | Pages may be written                 |
//! | `PROT_EXEC`      | Pages may be executed                |
//! | `MAP_SHARED`     | Share mapping across processes       |
//! | `MAP_PRIVATE`    | Private copy-on-write mapping        |
//! | `MAP_ANONYMOUS`  | Mapping not backed by a file         |
//!
//! ## Example
//!
//! ```ignis
//! import LibC, CType from "std::libc";
//!
//! function main(): i32 {
//!   // Heap allocation
//!   let buf: CType::CVoidPtr = LibC::Allocator::malloc(256);
//!   LibC::MemoryOperations::memset(buf, 0, 256);
//!   LibC::Allocator::free(buf);
//!
//!   // Anonymous mmap
//!   let page: CType::CVoidPtr = LibC::Memory::mmap(
//!     null, 4096,
//!     LibC::Memory::PROT_READ | LibC::Memory::PROT_WRITE,
//!     LibC::Memory::MAP_PRIVATE | LibC::Memory::MAP_ANONYMOUS,
//!     -1, 0,
//!   );
//!   LibC::Memory::munmap(page, 4096);
//!
//!   return 0;
//! }
//! ```

import CType from "./primitives";

extern __stdlib_alloc {
  function malloc(size: CType::SizeT): CType::CVoidPtr;
  function calloc(count: CType::SizeT, size: CType::SizeT): CType::CVoidPtr;
  function realloc(ptr: CType::CVoidPtr, size: CType::SizeT): CType::CVoidPtr;
  function free(ptr: CType::CVoidPtr): void;
}

extern __string_mem {
  function memcpy(dest: CType::CVoidPtr, src: CType::CConstVoidPtr, n: CType::SizeT): CType::CVoidPtr;
  function memmove(dest: CType::CVoidPtr, src: CType::CConstVoidPtr, n: CType::SizeT): CType::CVoidPtr;
  function memset(dest: CType::CVoidPtr, c: CType::CInt, n: CType::SizeT): CType::CVoidPtr;
  function memcmp(s1: CType::CConstVoidPtr, s2: CType::CConstVoidPtr, n: CType::SizeT): CType::CInt;
}

@configFlag(@platform("linux") || @platform("macos"))
extern __unistd_mem {
  function sbrk(increment: CType::IntPtrT): CType::CVoidPtr;
  function brk(addr: CType::CVoidPtr): CType::CInt;
}

@configFlag(@platform("linux") || @platform("macos"))
extern __mman {
  const PROT_NONE: CType::CInt;
  const PROT_READ: CType::CInt;
  const PROT_WRITE: CType::CInt;
  const PROT_EXEC: CType::CInt;
  const MAP_SHARED: CType::CInt;
  const MAP_PRIVATE: CType::CInt;
  const MAP_ANONYMOUS: CType::CInt;

  function mmap(addr: CType::CVoidPtr, length: CType::SizeT, prot: CType::CInt, flags: CType::CInt, fd: CType::CInt, offset: CType::OffT): CType::CVoidPtr;
  function munmap(addr: CType::CVoidPtr, length: CType::SizeT): CType::CInt;
  function mprotect(addr: CType::CVoidPtr, len: CType::SizeT, prot: CType::CInt): CType::CInt;
}

/// Memory allocation (stdlib.h)
namespace LibC::Allocator {
  /// Allocates `size` bytes of uninitialized memory.
  ///
  /// Returns a pointer to the allocated block, or null on failure.
  function malloc(size: CType::SizeT): CType::CVoidPtr { return __stdlib_alloc::malloc(size); }

  /// Allocates zero-initialized memory for `count` objects of `size` bytes each.
  ///
  /// Returns a pointer to the allocated block, or null on failure.
  function calloc(count: CType::SizeT, size: CType::SizeT): CType::CVoidPtr { return __stdlib_alloc::calloc(count, size); }

  /// Changes the size of the allocation at `ptr` to `size` bytes.
  ///
  /// The contents are preserved up to the minimum of old and new sizes.
  /// Returns a (possibly moved) pointer, or null on failure.
  function realloc(ptr: CType::CVoidPtr, size: CType::SizeT): CType::CVoidPtr { return __stdlib_alloc::realloc(ptr, size); }

  /// Frees memory previously returned by `malloc`, `calloc`, or `realloc`.
  function free(ptr: CType::CVoidPtr): void { __stdlib_alloc::free(ptr); }
}

/// Memory operations (string.h)
namespace LibC::MemoryOperations {
  /// Copies `n` bytes from `src` to `dest`. Regions must not overlap.
  function memcpy(dest: CType::CVoidPtr, src: CType::CConstVoidPtr, n: CType::SizeT): CType::CVoidPtr { return __string_mem::memcpy(dest, src, n); }

  /// Copies `n` bytes from `src` to `dest`. Handles overlapping regions.
  function memmove(dest: CType::CVoidPtr, src: CType::CConstVoidPtr, n: CType::SizeT): CType::CVoidPtr { return __string_mem::memmove(dest, src, n); }

  /// Fills `n` bytes of `dest` with the byte value `c`.
  function memset(dest: CType::CVoidPtr, c: CType::CInt, n: CType::SizeT): CType::CVoidPtr { return __string_mem::memset(dest, c, n); }

  /// Compares `n` bytes of `s1` and `s2`. Returns 0 if equal.
  function memcmp(s1: CType::CConstVoidPtr, s2: CType::CConstVoidPtr, n: CType::SizeT): CType::CInt { return __string_mem::memcmp(s1, s2, n); }
}

/// Low-level memory: sbrk, brk, mmap (sys/mman.h, unistd.h) â€” POSIX only.
@configFlag(@platform("linux") || @platform("macos"))
namespace LibC::Memory {
  /// No access permitted.
  const PROT_NONE: CType::CInt = __mman::PROT_NONE;

  /// Pages may be read.
  const PROT_READ: CType::CInt = __mman::PROT_READ;

  /// Pages may be written.
  const PROT_WRITE: CType::CInt = __mman::PROT_WRITE;

  /// Pages may be executed.
  const PROT_EXEC: CType::CInt = __mman::PROT_EXEC;

  /// Share mapping across processes.
  const MAP_SHARED: CType::CInt = __mman::MAP_SHARED;

  /// Private copy-on-write mapping.
  const MAP_PRIVATE: CType::CInt = __mman::MAP_PRIVATE;

  /// Mapping is not backed by a file.
  const MAP_ANONYMOUS: CType::CInt = __mman::MAP_ANONYMOUS;

  /// Adjusts the program break by `increment` bytes. Low-level.
  function sbrk(increment: CType::IntPtrT): CType::CVoidPtr { return __unistd_mem::sbrk(increment); }

  /// Sets the program break to `addr`. Low-level.
  function brk(addr: CType::CVoidPtr): CType::CInt { return __unistd_mem::brk(addr); }

  /// Maps `length` bytes into the process address space.
  ///
  /// Use `PROT_*` for protection and `MAP_*` for flags. Pass `fd = -1` with
  /// `MAP_ANONYMOUS` for anonymous mappings.
  function mmap(addr: CType::CVoidPtr, length: CType::SizeT, prot: CType::CInt, flags: CType::CInt, fd: CType::CInt, offset: CType::OffT): CType::CVoidPtr { return __mman::mmap(addr, length, prot, flags, fd, offset); }

  /// Unmaps `length` bytes starting at `addr`. Returns 0 on success.
  function munmap(addr: CType::CVoidPtr, length: CType::SizeT): CType::CInt { return __mman::munmap(addr, length); }

  /// Changes the protection on `len` bytes starting at `addr`.
  function mprotect(addr: CType::CVoidPtr, len: CType::SizeT, prot: CType::CInt): CType::CInt { return __mman::mprotect(addr, len, prot); }
}

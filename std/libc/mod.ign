//!
//! # LibC Module
//!
//! Raw bindings to a POSIX-oriented libc surface.
//!
//! ## Overview
//!
//! This module exposes a curated subset of POSIX/C standard library functions
//! directly to Ignis code. Functions use C-compatible signatures and semantics,
//! with all types coming from the `CType` namespace (see `std::libc/primitives`).
//!
//! No safety guarantees are added by this module. The caller is responsible
//! for correct pointer usage, buffer sizes, and lifetime management.
//!
//! ## Organization
//!
//! The `LibC` namespace groups functions by category:
//!
//! | Category              | C Header        | Functions                                         |
//! |-----------------------|-----------------|----------------------------------------------------|
//! | Memory allocation     | `stdlib.h`      | `malloc`, `calloc`, `realloc`, `free`              |
//! | Memory operations     | `string.h`      | `memcpy`, `memmove`, `memset`, `memcmp`            |
//! | String operations     | `string.h`      | `strlen`, `strcmp`, `strcpy`, `strcat`, `strstr`... |
//! | Process control       | `stdlib.h`      | `exit`, `abort`, `_exit`, `system`, `getenv`       |
//! | Conversion            | `stdlib.h`      | `atoi`, `atol`, `atof`                             |
//! | Integer math          | `stdlib.h`      | `abs`, `labs`                                      |
//! | Character class       | `ctype.h`       | `isalnum`, `isdigit`, `toupper`, `tolower`...      |
//! | Time                  | `time.h`        | `time`, `clock`                                    |
//! | File descriptors      | `unistd.h`      | `read`, `write`, `open`, `close`, `lseek`...       |
//! | Memory mapping        | `sys/mman.h`    | `mmap`, `munmap`, `mprotect`                       |
//! | Signals               | `signal.h`      | `raise`, `kill`                                    |
//! | Wait                  | `sys/wait.h`    | `wait`, `waitpid`                                  |
//!
//! ## Constants
//!
//! The `LibC` namespace also defines commonly used constants:
//!
//! - **Seek**: `SEEK_SET`, `SEEK_CUR`, `SEEK_END`
//! - **File descriptors**: `STDIN_FILENO`, `STDOUT_FILENO`, `STDERR_FILENO`
//! - **Exit codes**: `EXIT_SUCCESS`, `EXIT_FAILURE`
//! - **Open flags**: `O_RDONLY`, `O_WRONLY`, `O_RDWR`, `O_CREAT`, `O_TRUNC`, `O_APPEND`
//! - **mmap**: `PROT_NONE/READ/WRITE/EXEC`, `MAP_SHARED/PRIVATE/ANONYMOUS`
//! - **Signals**: `SIGINT`, `SIGKILL`, `SIGSEGV`, `SIGTERM`
//! - **Clock**: `CLOCKS_PER_SEC`
//!
//! ## Platform Assumptions
//!
//! - LP64 type sizes (Linux/macOS 64-bit)
//! - Linux `open()` flag values
//! - Linux mmap flag values
//!
//! ## Example
//!
//! ```ignis
//! import LibC, CType from "std::libc";
//! import Io from "std::io";
//! import String from "std::string";
//!
//! function main(): i32 {
//!   // Get process ID
//!   let pid: CType::PidT = LibC::getpid();
//!   Io::println(String::create(pid as i32));
//!
//!   // Allocate and free memory
//!   let buf: CType::CVoidPtr = LibC::malloc(1024);
//!   LibC::free(buf);
//!
//!   // Read environment variable
//!   let home: CType::CStr = LibC::getenv("HOME");
//!
//!   return 0;
//! }
//! ```

import CType from "./primitives";

// Re-export primitive types
export CType;

// =============================================================================
// Memory allocation (stdlib.h)
// =============================================================================

extern __stdlib {
  function malloc(size: CType::SizeT): CType::CVoidPtr;
  function calloc(count: CType::SizeT, size: CType::SizeT): CType::CVoidPtr;
  function realloc(ptr: CType::CVoidPtr, size: CType::SizeT): CType::CVoidPtr;
  function free(ptr: CType::CVoidPtr): void;
}

// =============================================================================
// Memory operations (string.h)
// =============================================================================

extern __string_h {
  function memcpy(dest: CType::CVoidPtr, src: CType::CConstVoidPtr, n: CType::SizeT): CType::CVoidPtr;
  function memmove(dest: CType::CVoidPtr, src: CType::CConstVoidPtr, n: CType::SizeT): CType::CVoidPtr;
  function memset(dest: CType::CVoidPtr, c: CType::CInt, n: CType::SizeT): CType::CVoidPtr;
  function memcmp(s1: CType::CConstVoidPtr, s2: CType::CConstVoidPtr, n: CType::SizeT): CType::CInt;
}

// =============================================================================
// String operations (string.h)
// =============================================================================

extern __string_ops {
  function strlen(s: CType::CConstStr): CType::SizeT;
  function strcmp(s1: CType::CConstStr, s2: CType::CConstStr): CType::CInt;
  function strncmp(s1: CType::CConstStr, s2: CType::CConstStr, n: CType::SizeT): CType::CInt;
  function strcpy(dest: CType::CStr, src: CType::CConstStr): CType::CStr;
  function strncpy(dest: CType::CStr, src: CType::CConstStr, n: CType::SizeT): CType::CStr;
  function strcat(dest: CType::CStr, src: CType::CConstStr): CType::CStr;
  function strncat(dest: CType::CStr, src: CType::CConstStr, n: CType::SizeT): CType::CStr;
  function strchr(s: CType::CConstStr, c: CType::CInt): CType::CStr;
  function strrchr(s: CType::CConstStr, c: CType::CInt): CType::CStr;
  function strstr(haystack: CType::CConstStr, needle: CType::CConstStr): CType::CStr;
  function strdup(s: CType::CConstStr): CType::CStr;
  function strerror(errnum: CType::CInt): CType::CStr;
}

// =============================================================================
// Process control (stdlib.h)
// =============================================================================

extern __process {
  function exit(status: CType::CInt): void;
  function abort(): void;
  function _exit(status: CType::CInt): void;
  function system(command: CType::CConstStr): CType::CInt;
  function getenv(name: CType::CConstStr): CType::CStr;
}

// =============================================================================
// Conversion (stdlib.h) - simple versions only
// =============================================================================

extern __convert {
  function atoi(s: CType::CConstStr): CType::CInt;
  function atol(s: CType::CConstStr): CType::CLong;
  function atof(s: CType::CConstStr): CType::CDouble;
}

// =============================================================================
// Math (stdlib.h)
// =============================================================================

extern __math_h {
  function abs(x: CType::CInt): CType::CInt;
  function labs(x: CType::CLong): CType::CLong;
}

// =============================================================================
// Character classification (ctype.h)
// =============================================================================

extern __ctype {
  function isalnum(c: CType::CInt): CType::CInt;
  function isalpha(c: CType::CInt): CType::CInt;
  function isdigit(c: CType::CInt): CType::CInt;
  function isxdigit(c: CType::CInt): CType::CInt;
  function islower(c: CType::CInt): CType::CInt;
  function isupper(c: CType::CInt): CType::CInt;
  function isspace(c: CType::CInt): CType::CInt;
  function ispunct(c: CType::CInt): CType::CInt;
  function isprint(c: CType::CInt): CType::CInt;
  function iscntrl(c: CType::CInt): CType::CInt;
  function isgraph(c: CType::CInt): CType::CInt;
  function tolower(c: CType::CInt): CType::CInt;
  function toupper(c: CType::CInt): CType::CInt;
}

// =============================================================================
// Time (time.h)
// =============================================================================

extern __time_h {
  function time(tloc: *mut CType::TimeT): CType::TimeT;
  function clock(): CType::ClockT;
}

// =============================================================================
// POSIX file descriptors (unistd.h / fcntl.h)
// =============================================================================

extern __unistd {
  function read(fd: CType::CInt, buf: CType::CVoidPtr, count: CType::SizeT): CType::SSizeT;
  function write(fd: CType::CInt, buf: CType::CConstVoidPtr, count: CType::SizeT): CType::SSizeT;
  function open(pathname: CType::CConstStr, flags: CType::CInt): CType::CInt;
  function close(fd: CType::CInt): CType::CInt;
  function lseek(fd: CType::CInt, offset: CType::OffT, whence: CType::CInt): CType::OffT;
  function unlink(pathname: CType::CConstStr): CType::CInt;
  function rmdir(pathname: CType::CConstStr): CType::CInt;
  function getcwd(buf: CType::CStr, size: CType::SizeT): CType::CStr;
  function chdir(path: CType::CConstStr): CType::CInt;
  function getpid(): CType::PidT;
  function getppid(): CType::PidT;
  function getuid(): CType::UidT;
  function getgid(): CType::GidT;
  function sleep(seconds: CType::CUInt): CType::CUInt;
  function usleep(usec: CType::CUInt): CType::CInt;
  function fork(): CType::PidT;
  function pipe(pipefd: *mut CType::CInt): CType::CInt;
  function dup(oldfd: CType::CInt): CType::CInt;
  function dup2(oldfd: CType::CInt, newfd: CType::CInt): CType::CInt;
  function isatty(fd: CType::CInt): CType::CInt;
  function sbrk(increment: CType::IntPtrT): CType::CVoidPtr;
  function brk(addr: CType::CVoidPtr): CType::CInt;
}

// =============================================================================
// Memory mapping (sys/mman.h)
// =============================================================================

extern __mman {
  function mmap(addr: CType::CVoidPtr, length: CType::SizeT, prot: CType::CInt, flags: CType::CInt, fd: CType::CInt, offset: CType::OffT): CType::CVoidPtr;
  function munmap(addr: CType::CVoidPtr, length: CType::SizeT): CType::CInt;
  function mprotect(addr: CType::CVoidPtr, len: CType::SizeT, prot: CType::CInt): CType::CInt;
}

// =============================================================================
// Signals (signal.h) - primitives only
// =============================================================================

extern __signal {
  function raise(sig: CType::CInt): CType::CInt;
  function kill(pid: CType::PidT, sig: CType::CInt): CType::CInt;
}

// =============================================================================
// Wait (sys/wait.h)
// =============================================================================

extern __wait {
  function wait(wstatus: *mut CType::CInt): CType::PidT;
  function waitpid(pid: CType::PidT, wstatus: *mut CType::CInt, options: CType::CInt): CType::PidT;
}

// =============================================================================
// API namespace with constants
// =============================================================================

/// Curated POSIX/C standard library bindings.
///
/// Provides constants and functions grouped by category. All types use the
/// `CType` namespace from `std::libc/primitives`. No safety guarantees are
/// added — the caller is responsible for pointer validity, buffer sizes, and
/// lifetime management.
export namespace LibC {

  // =========================================================================
  // Constants — seek
  // =========================================================================

  /// Seek from beginning of file.
  const SEEK_SET: CType::CInt = 0;

  /// Seek from current position.
  const SEEK_CUR: CType::CInt = 1;

  /// Seek from end of file.
  const SEEK_END: CType::CInt = 2;

  // =========================================================================
  // Constants — standard file descriptors
  // =========================================================================

  /// Standard input file descriptor.
  const STDIN_FILENO: CType::CInt = 0;

  /// Standard output file descriptor.
  const STDOUT_FILENO: CType::CInt = 1;

  /// Standard error file descriptor.
  const STDERR_FILENO: CType::CInt = 2;

  // =========================================================================
  // Constants — exit codes
  // =========================================================================

  /// Successful exit status.
  const EXIT_SUCCESS: CType::CInt = 0;

  /// Failure exit status.
  const EXIT_FAILURE: CType::CInt = 1;

  // =========================================================================
  // Constants — open flags (Linux values)
  // =========================================================================

  /// Open for reading only.
  const O_RDONLY: CType::CInt = 0;

  /// Open for writing only.
  const O_WRONLY: CType::CInt = 1;

  /// Open for reading and writing.
  const O_RDWR: CType::CInt = 2;

  /// Create file if it does not exist.
  const O_CREAT: CType::CInt = 64;

  /// Truncate file to zero length.
  const O_TRUNC: CType::CInt = 512;

  /// Append on each write.
  const O_APPEND: CType::CInt = 1024;

  // =========================================================================
  // Constants — mmap flags
  // =========================================================================

  /// No access permitted.
  const PROT_NONE: CType::CInt = 0;

  /// Pages may be read.
  const PROT_READ: CType::CInt = 1;

  /// Pages may be written.
  const PROT_WRITE: CType::CInt = 2;

  /// Pages may be executed.
  const PROT_EXEC: CType::CInt = 4;

  /// Share mapping across processes.
  const MAP_SHARED: CType::CInt = 1;

  /// Private copy-on-write mapping.
  const MAP_PRIVATE: CType::CInt = 2;

  /// Mapping is not backed by a file.
  const MAP_ANONYMOUS: CType::CInt = 32;
  // Note: MAP_FAILED is (void*)-1 in C. Check with mmap return != NULL and cast.

  // =========================================================================
  // Constants — signals
  // =========================================================================

  /// Interrupt from keyboard (Ctrl-C).
  const SIGINT: CType::CInt = 2;

  /// Kill signal (cannot be caught).
  const SIGKILL: CType::CInt = 9;

  /// Segmentation fault.
  const SIGSEGV: CType::CInt = 11;

  /// Termination signal.
  const SIGTERM: CType::CInt = 15;

  // =========================================================================
  // Constants — clock
  // =========================================================================

  /// `clock()` ticks per second (POSIX: 1,000,000).
  const CLOCKS_PER_SEC: CType::ClockT = 1000000;

  // =========================================================================
  // Memory allocation (stdlib.h)
  // =========================================================================

  /// Allocates `size` bytes of uninitialized memory.
  ///
  /// Returns a pointer to the allocated block, or null on failure.
  function malloc(size: CType::SizeT): CType::CVoidPtr { return __stdlib::malloc(size); }

  /// Allocates zero-initialized memory for `count` objects of `size` bytes each.
  ///
  /// Returns a pointer to the allocated block, or null on failure.
  function calloc(count: CType::SizeT, size: CType::SizeT): CType::CVoidPtr { return __stdlib::calloc(count, size); }

  /// Changes the size of the allocation at `ptr` to `size` bytes.
  ///
  /// The contents are preserved up to the minimum of old and new sizes.
  /// Returns a (possibly moved) pointer, or null on failure.
  function realloc(ptr: CType::CVoidPtr, size: CType::SizeT): CType::CVoidPtr { return __stdlib::realloc(ptr, size); }

  /// Frees memory previously returned by `malloc`, `calloc`, or `realloc`.
  function free(ptr: CType::CVoidPtr): void { __stdlib::free(ptr); }

  // =========================================================================
  // Memory operations (string.h)
  // =========================================================================

  /// Copies `n` bytes from `src` to `dest`. Regions must not overlap.
  function memcpy(dest: CType::CVoidPtr, src: CType::CConstVoidPtr, n: CType::SizeT): CType::CVoidPtr { return __string_h::memcpy(dest, src, n); }

  /// Copies `n` bytes from `src` to `dest`. Handles overlapping regions.
  function memmove(dest: CType::CVoidPtr, src: CType::CConstVoidPtr, n: CType::SizeT): CType::CVoidPtr { return __string_h::memmove(dest, src, n); }

  /// Fills `n` bytes of `dest` with the byte value `c`.
  function memset(dest: CType::CVoidPtr, c: CType::CInt, n: CType::SizeT): CType::CVoidPtr { return __string_h::memset(dest, c, n); }

  /// Compares `n` bytes of `s1` and `s2`. Returns 0 if equal.
  function memcmp(s1: CType::CConstVoidPtr, s2: CType::CConstVoidPtr, n: CType::SizeT): CType::CInt { return __string_h::memcmp(s1, s2, n); }

  // =========================================================================
  // String operations (string.h)
  // =========================================================================

  /// Returns the length of the null-terminated string `s`.
  function strlen(s: CType::CConstStr): CType::SizeT { return __string_ops::strlen(s); }

  /// Compares two null-terminated strings. Returns 0 if equal.
  function strcmp(s1: CType::CConstStr, s2: CType::CConstStr): CType::CInt { return __string_ops::strcmp(s1, s2); }

  /// Compares at most `n` bytes of two strings. Returns 0 if equal.
  function strncmp(s1: CType::CConstStr, s2: CType::CConstStr, n: CType::SizeT): CType::CInt { return __string_ops::strncmp(s1, s2, n); }

  /// Copies `src` to `dest` including the null terminator.
  function strcpy(dest: CType::CStr, src: CType::CConstStr): CType::CStr { return __string_ops::strcpy(dest, src); }

  /// Copies at most `n` bytes from `src` to `dest`, null-padding if `src` is shorter.
  function strncpy(dest: CType::CStr, src: CType::CConstStr, n: CType::SizeT): CType::CStr { return __string_ops::strncpy(dest, src, n); }

  /// Appends `src` to the end of `dest`.
  function strcat(dest: CType::CStr, src: CType::CConstStr): CType::CStr { return __string_ops::strcat(dest, src); }

  /// Appends at most `n` bytes of `src` to `dest`.
  function strncat(dest: CType::CStr, src: CType::CConstStr, n: CType::SizeT): CType::CStr { return __string_ops::strncat(dest, src, n); }

  /// Finds the first occurrence of byte `c` in string `s`.
  function strchr(s: CType::CConstStr, c: CType::CInt): CType::CStr { return __string_ops::strchr(s, c); }

  /// Finds the last occurrence of byte `c` in string `s`.
  function strrchr(s: CType::CConstStr, c: CType::CInt): CType::CStr { return __string_ops::strrchr(s, c); }

  /// Finds the first occurrence of `needle` in `haystack`.
  function strstr(haystack: CType::CConstStr, needle: CType::CConstStr): CType::CStr { return __string_ops::strstr(haystack, needle); }

  /// Duplicates a string into newly allocated memory. Caller must free.
  function strdup(s: CType::CConstStr): CType::CStr { return __string_ops::strdup(s); }

  /// Returns a human-readable string for the given error number.
  function strerror(errnum: CType::CInt): CType::CStr { return __string_ops::strerror(errnum); }

  // =========================================================================
  // Process control (stdlib.h)
  // =========================================================================

  /// Terminates the process with `status`. Does not return.
  function exit(status: CType::CInt): void { __process::exit(status); }

  /// Terminates the process abnormally. Does not return.
  function abort(): void { __process::abort(); }

  /// Terminates the process immediately without running atexit handlers.
  function _exit(status: CType::CInt): void { __process::_exit(status); }

  /// Executes `command` via the system shell. Returns the exit status.
  function system(command: CType::CConstStr): CType::CInt { return __process::system(command); }

  /// Returns the value of environment variable `name`, or null if unset.
  function getenv(name: CType::CConstStr): CType::CStr { return __process::getenv(name); }

  // =========================================================================
  // Conversion (stdlib.h)
  // =========================================================================

  /// Converts a decimal string to `CInt`.
  function atoi(s: CType::CConstStr): CType::CInt { return __convert::atoi(s); }

  /// Converts a decimal string to `CLong`.
  function atol(s: CType::CConstStr): CType::CLong { return __convert::atol(s); }

  /// Converts a string to `CDouble`.
  function atof(s: CType::CConstStr): CType::CDouble { return __convert::atof(s); }

  // =========================================================================
  // Integer math (stdlib.h)
  // =========================================================================

  /// Returns the absolute value of `x`.
  function abs(x: CType::CInt): CType::CInt { return __math_h::abs(x); }

  /// Returns the absolute value of `x` (long version).
  function labs(x: CType::CLong): CType::CLong { return __math_h::labs(x); }

  // =========================================================================
  // Character classification (ctype.h)
  // =========================================================================

  /// Tests if `c` is alphanumeric.
  function isalnum(c: CType::CInt): CType::CInt { return __ctype::isalnum(c); }

  /// Tests if `c` is alphabetic.
  function isalpha(c: CType::CInt): CType::CInt { return __ctype::isalpha(c); }

  /// Tests if `c` is a decimal digit.
  function isdigit(c: CType::CInt): CType::CInt { return __ctype::isdigit(c); }

  /// Tests if `c` is a hexadecimal digit.
  function isxdigit(c: CType::CInt): CType::CInt { return __ctype::isxdigit(c); }

  /// Tests if `c` is a lowercase letter.
  function islower(c: CType::CInt): CType::CInt { return __ctype::islower(c); }

  /// Tests if `c` is an uppercase letter.
  function isupper(c: CType::CInt): CType::CInt { return __ctype::isupper(c); }

  /// Tests if `c` is a whitespace character.
  function isspace(c: CType::CInt): CType::CInt { return __ctype::isspace(c); }

  /// Tests if `c` is a punctuation character.
  function ispunct(c: CType::CInt): CType::CInt { return __ctype::ispunct(c); }

  /// Tests if `c` is a printable character (including space).
  function isprint(c: CType::CInt): CType::CInt { return __ctype::isprint(c); }

  /// Tests if `c` is a control character.
  function iscntrl(c: CType::CInt): CType::CInt { return __ctype::iscntrl(c); }

  /// Tests if `c` is a printable character excluding space.
  function isgraph(c: CType::CInt): CType::CInt { return __ctype::isgraph(c); }

  /// Converts `c` to lowercase if it is an uppercase letter.
  function tolower(c: CType::CInt): CType::CInt { return __ctype::tolower(c); }

  /// Converts `c` to uppercase if it is a lowercase letter.
  function toupper(c: CType::CInt): CType::CInt { return __ctype::toupper(c); }

  // =========================================================================
  // Time (time.h)
  // =========================================================================

  /// Returns the current calendar time (seconds since epoch).
  ///
  /// If `tloc` is non-null, the result is also stored there.
  function time(tloc: *mut CType::TimeT): CType::TimeT { return __time_h::time(tloc); }

  /// Returns processor time consumed by the program in clock ticks.
  ///
  /// Divide by `CLOCKS_PER_SEC` to get seconds.
  function clock(): CType::ClockT { return __time_h::clock(); }

  // =========================================================================
  // POSIX file descriptors (unistd.h / fcntl.h)
  // =========================================================================

  /// Reads up to `count` bytes from file descriptor `fd` into `buf`.
  ///
  /// Returns the number of bytes read, 0 on EOF, or -1 on error.
  function read(fd: CType::CInt, buf: CType::CVoidPtr, count: CType::SizeT): CType::SSizeT { return __unistd::read(fd, buf, count); }

  /// Writes up to `count` bytes from `buf` to file descriptor `fd`.
  ///
  /// Returns the number of bytes written, or -1 on error.
  function write(fd: CType::CInt, buf: CType::CConstVoidPtr, count: CType::SizeT): CType::SSizeT { return __unistd::write(fd, buf, count); }

  /// Opens the file at `pathname` with the given `flags`.
  ///
  /// Returns a file descriptor, or -1 on error.
  function open(pathname: CType::CConstStr, flags: CType::CInt): CType::CInt { return __unistd::open(pathname, flags); }

  /// Closes file descriptor `fd`. Returns 0 on success, -1 on error.
  function close(fd: CType::CInt): CType::CInt { return __unistd::close(fd); }

  /// Repositions the file offset of `fd`. Use `SEEK_SET`/`CUR`/`END` for `whence`.
  ///
  /// Returns the new offset, or -1 on error.
  function lseek(fd: CType::CInt, offset: CType::OffT, whence: CType::CInt): CType::OffT { return __unistd::lseek(fd, offset, whence); }

  /// Deletes a name from the filesystem. Returns 0 on success.
  function unlink(pathname: CType::CConstStr): CType::CInt { return __unistd::unlink(pathname); }

  /// Removes an empty directory. Returns 0 on success.
  function rmdir(pathname: CType::CConstStr): CType::CInt { return __unistd::rmdir(pathname); }

  /// Writes the current working directory into `buf` (up to `size` bytes).
  function getcwd(buf: CType::CStr, size: CType::SizeT): CType::CStr { return __unistd::getcwd(buf, size); }

  /// Changes the current working directory to `path`.
  function chdir(path: CType::CConstStr): CType::CInt { return __unistd::chdir(path); }

  /// Returns the process ID of the calling process.
  function getpid(): CType::PidT { return __unistd::getpid(); }

  /// Returns the parent process ID.
  function getppid(): CType::PidT { return __unistd::getppid(); }

  /// Returns the real user ID of the calling process.
  function getuid(): CType::UidT { return __unistd::getuid(); }

  /// Returns the real group ID of the calling process.
  function getgid(): CType::GidT { return __unistd::getgid(); }

  /// Suspends execution for `seconds` seconds.
  ///
  /// Returns 0 on success, or the remaining seconds if interrupted.
  function sleep(seconds: CType::CUInt): CType::CUInt { return __unistd::sleep(seconds); }

  /// Suspends execution for `usec` microseconds.
  function usleep(usec: CType::CUInt): CType::CInt { return __unistd::usleep(usec); }

  /// Creates a new process by duplicating the calling process.
  ///
  /// Returns the child PID to the parent, 0 to the child, or -1 on error.
  function fork(): CType::PidT { return __unistd::fork(); }

  /// Creates a unidirectional pipe. `pipefd[0]` is the read end,
  /// `pipefd[1]` is the write end.
  function pipe(pipefd: *mut CType::CInt): CType::CInt { return __unistd::pipe(pipefd); }

  /// Duplicates file descriptor `oldfd`. Returns the new fd or -1.
  function dup(oldfd: CType::CInt): CType::CInt { return __unistd::dup(oldfd); }

  /// Duplicates `oldfd` to `newfd`, closing `newfd` first if open.
  function dup2(oldfd: CType::CInt, newfd: CType::CInt): CType::CInt { return __unistd::dup2(oldfd, newfd); }

  /// Tests whether `fd` refers to a terminal. Returns 1 if true.
  function isatty(fd: CType::CInt): CType::CInt { return __unistd::isatty(fd); }

  /// Adjusts the program break by `increment` bytes. Low-level.
  function sbrk(increment: CType::IntPtrT): CType::CVoidPtr { return __unistd::sbrk(increment); }

  /// Sets the program break to `addr`. Low-level.
  function brk(addr: CType::CVoidPtr): CType::CInt { return __unistd::brk(addr); }

  // =========================================================================
  // Memory mapping (sys/mman.h)
  // =========================================================================

  /// Maps `length` bytes into the process address space.
  ///
  /// Use `PROT_*` for protection and `MAP_*` for flags. Pass `fd = -1` with
  /// `MAP_ANONYMOUS` for anonymous mappings.
  function mmap(addr: CType::CVoidPtr, length: CType::SizeT, prot: CType::CInt, flags: CType::CInt, fd: CType::CInt, offset: CType::OffT): CType::CVoidPtr { return __mman::mmap(addr, length, prot, flags, fd, offset); }

  /// Unmaps `length` bytes starting at `addr`. Returns 0 on success.
  function munmap(addr: CType::CVoidPtr, length: CType::SizeT): CType::CInt { return __mman::munmap(addr, length); }

  /// Changes the protection on `len` bytes starting at `addr`.
  function mprotect(addr: CType::CVoidPtr, len: CType::SizeT, prot: CType::CInt): CType::CInt { return __mman::mprotect(addr, len, prot); }

  // =========================================================================
  // Signals (signal.h)
  // =========================================================================

  /// Sends signal `sig` to the calling process.
  function raise(sig: CType::CInt): CType::CInt { return __signal::raise(sig); }

  /// Sends signal `sig` to process `pid`.
  function kill(pid: CType::PidT, sig: CType::CInt): CType::CInt { return __signal::kill(pid, sig); }

  // =========================================================================
  // Wait (sys/wait.h)
  // =========================================================================

  /// Waits for any child process to change state.
  ///
  /// Stores the status in `wstatus`. Returns the child PID.
  function wait(wstatus: *mut CType::CInt): CType::PidT { return __wait::wait(wstatus); }

  /// Waits for a specific child process `pid` to change state.
  ///
  /// `options` can be 0 or a combination of `WNOHANG`/`WUNTRACED`.
  function waitpid(pid: CType::PidT, wstatus: *mut CType::CInt, options: CType::CInt): CType::PidT { return __wait::waitpid(pid, wstatus, options); }
}

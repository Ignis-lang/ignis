//!
//! # String Module
//!
//! Owned, heap-backed byte string type and related utilities.
//!
//! ## Overview
//!
//! `String` is a value-type record whose `data` buffer lives on the heap.
//! It implements `Drop` so the buffer is freed automatically when the
//! owning binding goes out of scope, and `Clone` for explicit deep copies.
//!
//! `str` is the primitive immutable string-slice type (`const char*` in C).
//! String literals have type `str`.  Use `String::create(s)` to create an
//! owned copy from a `str`.
//!
//! ## Memory Layout
//!
//! ```text
//!   String
//!   ┌──────────────┐
//!   │ data ────────┼──────► ┌───┬───┬───┬───┬───┬───┬───┬───┐
//!   │ len: 5       │        │ h │ e │ l │ l │ o │   │   │   │
//!   │ cap: 8       │        └───┴───┴───┴───┴───┴───┴───┴───┘
//!   └──────────────┘        ◄── used bytes ──►◄─ reserved ──►
//! ```
//!
//! Fields mirror the C runtime's `IgnisString` layout exactly:
//! - `data` — pointer to the backing byte buffer (or `null` before init)
//! - `len`  — number of bytes currently stored
//! - `cap`  — total bytes allocated
//!
//! ## Byte-Oriented Operations
//!
//! All operations in this module are **byte-oriented** (no UTF-8 awareness).
//! Methods like `charAt`, `forEachByte`, `findByte`, `trimWhere`, and `split`
//! work on individual bytes (`u8`), not Unicode code points.
//!
//! ## Higher-Order Byte Methods
//!
//! String provides callback-based operations for byte-level iteration,
//! searching, trimming, and splitting:
//!
//! | Method        | Signature                              | Description                        |
//! |---------------|----------------------------------------|------------------------------------|
//! | `forEachByte` | `(u8) -> void`                         | Iterate over every byte            |
//! | `findByte`    | `(u8) -> boolean` → `Option<u64>`      | Index of first matching byte       |
//! | `trimWhere`   | `(u8) -> boolean` → `String`           | Strip leading/trailing bytes       |
//! | `split`       | `(u8) -> boolean` → `Vector<String>`   | Split into segments                |
//!
//! All callbacks are `@noescape`: the closure must not outlive the method call.
//!
//! ## Numeric Conversions
//!
//! `String::create` is overloaded for all numeric primitives (`i8` through
//! `f64`), plus `str`. Extension methods provide `.toString()` on every
//! primitive type.
//!
//! ## Example
//!
//! ```ignis
//! import String from "std::string";
//! import Io from "std::io";
//!
//! function main(): i32 {
//!   let greeting: String = String::create("hello");
//!   let world: String = String::create(" world");
//!   let msg: String = greeting.concat(&world);
//!
//!   Io::println(msg);
//!
//!   // Byte-level: trim whitespace and split on commas
//!   let csv: String = String::create("  a,b,c  ");
//!   let trimmed: String = csv.trimWhere(|b: u8| -> boolean { return b == 32; });
//!   let parts: Vector<String> = trimmed.split(|b: u8| -> boolean { return b == 44; });
//!   // parts: ["a", "b", "c"]
//!
//!   return 0;
//! }
//! ```

extern __string {
  // Init functions (write into &mut String, never return by value)
  function ignis_string_init_new(out: &mut String): void;
  function ignis_string_init_with_capacity(out: &mut String, cap: u64): void;
  function ignis_string_init_from_cstr(out: &mut String, s: str): void;
  function ignis_string_init_clone(out: &mut String, s: &String): void;
  function ignis_string_init_concat(out: &mut String, a: &String, b: &String): void;
  function ignis_string_init_substring(out: &mut String, s: &String, start: i64, len: i64): void;
  function ignis_string_init_to_upper(out: &mut String, s: &String): void;
  function ignis_string_init_to_lower(out: &mut String, s: &String): void;

  // Read operations
  function ignis_string_len(s: &String): u64;
  function ignis_string_compare(a: &String, b: &String): i32;
  function ignis_string_char_at(s: &String, idx: u64): char;
  function ignis_string_index_of(haystack: &String, needle: &String): i64;
  function ignis_string_contains(haystack: &String, needle: &String): boolean;
  function ignis_string_cstr(s: &String): str;

  // Mutating operations
  function ignis_string_push_char(s: &mut String, c: char): void;
  function ignis_string_push_cstr(s: &mut String, cstr: str): void;
  function ignis_string_push_str(s: &mut String, other: &String): void;
  function ignis_string_clear(s: &mut String): void;
  function ignis_string_reserve(s: &mut String, additional: u64): void;
  function ignis_string_drop(s: &mut String): void;

  // Number-to-string init functions
  function ignis_string_init_from_i8(out: &mut String, value: i8): void;
  function ignis_string_init_from_i16(out: &mut String, value: i16): void;
  function ignis_string_init_from_i32(out: &mut String, value: i32): void;
  function ignis_string_init_from_i64(out: &mut String, value: i64): void;
  function ignis_string_init_from_u8(out: &mut String, value: u8): void;
  function ignis_string_init_from_u16(out: &mut String, value: u16): void;
  function ignis_string_init_from_u32(out: &mut String, value: u32): void;
  function ignis_string_init_from_u64(out: &mut String, value: u64): void;
  function ignis_string_init_from_f32(out: &mut String, value: f32): void;
  function ignis_string_init_from_f64(out: &mut String, value: f64): void;
}

/// Owned, heap-backed byte string.
///
/// The `data` buffer is heap-allocated and freed when the String is dropped.
/// All operations are byte-oriented (no UTF-8 decoding).
///
/// Implements `Drop` for automatic cleanup and `Clone` for deep copies.
///
/// # Fields
///
/// * `data` - Raw pointer to the heap byte buffer (`null` when uninitialized).
/// * `len`  - Number of bytes currently stored.
/// * `cap`  - Total capacity of the buffer in bytes.
///
/// # Example
///
/// ```ignis
/// import String from "std::string";
///
/// let s: String = String::create("ignis");
/// let len: u64 = s.length();  // 5
/// let c: Option<char> = s.charAt(0);  // Option::SOME('i')
/// ```
@implements(Drop, Clone)
export record String {
  /// Raw pointer to the heap byte buffer (`null` when uninitialized).
  data: *mut u8;

  /// Number of bytes currently stored.
  len: u64;

  /// Total capacity of the buffer in bytes.
  cap: u64;

  // ---------------------------------------------------------------------------
  // Static constructors
  // ---------------------------------------------------------------------------

  /// Creates a new empty string with default capacity.
  ///
  /// # Example
  ///
  /// ```ignis
  /// import String from "std::string";
  ///
  /// let mut s: String = String::new();
  /// s.pushStr("hello");
  /// ```
  public static new(): String {
    let mut result: String = String { data: null, len: 0, cap: 0 };
    __string::ignis_string_init_new(&mut result);
    return result;
  }

  /// Creates a new empty string with at least `capacity` bytes reserved.
  ///
  /// Use this when you know roughly how many bytes the string will hold,
  /// to avoid repeated reallocations during `push`/`pushStr`/`pushChar`.
  ///
  /// # Arguments
  ///
  /// * `capacity` - Minimum number of bytes to reserve.
  ///
  /// # Example
  ///
  /// ```ignis
  /// import String from "std::string";
  ///
  /// let mut s: String = String::withCapacity(256);
  /// s.pushStr("pre-allocated buffer");
  /// ```
  public static withCapacity(capacity: u64): String {
    let mut result: String = String { data: null, len: 0, cap: 0 };
    __string::ignis_string_init_with_capacity(&mut result, capacity);
    return result;
  }

  /// Creates an owned String from an immutable `str` literal.
  ///
  /// Copies the bytes from the `str` slice into a new heap allocation.
  /// This is the primary way to create a String from a string literal.
  ///
  /// # Arguments
  ///
  /// * `s` - The source `str` (immutable string slice / `const char*`).
  ///
  /// # Example
  ///
  /// ```ignis
  /// import String from "std::string";
  ///
  /// let greeting: String = String::create("hello world");
  /// ```
  public static create(s: str): String {
    let mut result: String = String { data: null, len: 0, cap: 0 };
    __string::ignis_string_init_from_cstr(&mut result, s);
    return result;
  }

  /// Creates an owned String from an `i8` value.
  ///
  /// # Numeric Overloads
  ///
  /// `String::create` is overloaded for every numeric primitive:
  /// `i8`, `i16`, `i32`, `i64`, `u8`, `u16`, `u32`, `u64`, `f32`, `f64`.
  ///
  /// Each converts the number to its decimal string representation.
  ///
  /// # Example
  ///
  /// ```ignis
  /// import String from "std::string";
  ///
  /// let a: String = String::create(42 as i32);   // "42"
  /// let b: String = String::create(3.14 as f64);  // "3.140000"
  /// let c: String = String::create(255 as u8);    // "255"
  /// ```
  public static create(value: i8): String {
    let mut result: String = String { data: null, len: 0, cap: 0 };
    __string::ignis_string_init_from_i8(&mut result, value);
    return result;
  }

  /// Creates an owned String from an `i16`.
  public static create(value: i16): String {
    let mut result: String = String { data: null, len: 0, cap: 0 };
    __string::ignis_string_init_from_i16(&mut result, value);
    return result;
  }

  /// Creates an owned String from an `i32`.
  public static create(value: i32): String {
    let mut result: String = String { data: null, len: 0, cap: 0 };
    __string::ignis_string_init_from_i32(&mut result, value);
    return result;
  }

  /// Creates an owned String from an `i64`.
  public static create(value: i64): String {
    let mut result: String = String { data: null, len: 0, cap: 0 };
    __string::ignis_string_init_from_i64(&mut result, value);
    return result;
  }

  /// Creates an owned String from a `u8`.
  public static create(value: u8): String {
    let mut result: String = String { data: null, len: 0, cap: 0 };
    __string::ignis_string_init_from_u8(&mut result, value);
    return result;
  }

  /// Creates an owned String from a `u16`.
  public static create(value: u16): String {
    let mut result: String = String { data: null, len: 0, cap: 0 };
    __string::ignis_string_init_from_u16(&mut result, value);
    return result;
  }

  /// Creates an owned String from a `u32`.
  public static create(value: u32): String {
    let mut result: String = String { data: null, len: 0, cap: 0 };
    __string::ignis_string_init_from_u32(&mut result, value);
    return result;
  }

  /// Creates an owned String from a `u64`.
  public static create(value: u64): String {
    let mut result: String = String { data: null, len: 0, cap: 0 };
    __string::ignis_string_init_from_u64(&mut result, value);
    return result;
  }

  /// Creates an owned String from an `f32`.
  public static create(value: f32): String {
    let mut result: String = String { data: null, len: 0, cap: 0 };
    __string::ignis_string_init_from_f32(&mut result, value);
    return result;
  }

  /// Creates an owned String from an `f64`.
  public static create(value: f64): String {
    let mut result: String = String { data: null, len: 0, cap: 0 };
    __string::ignis_string_init_from_f64(&mut result, value);
    return result;
  }

  // ---------------------------------------------------------------------------
  // Instance methods — read-only
  // ---------------------------------------------------------------------------

  /// Returns the string length in bytes.
  ///
  /// # Example
  ///
  /// ```ignis
  /// import String from "std::string";
  ///
  /// let s: String = String::create("hello");
  /// let len: u64 = s.length();  // 5
  /// ```
  public length(&self): u64 {
    return __string::ignis_string_len(self);
  }

  /// Lexicographically compares this string with `other` byte-by-byte.
  ///
  /// # Returns
  ///
  /// - Negative if `self < other`
  /// - Zero if `self == other`
  /// - Positive if `self > other`
  ///
  /// # Example
  ///
  /// ```ignis
  /// import String from "std::string";
  ///
  /// let a: String = String::create("apple");
  /// let b: String = String::create("banana");
  /// let cmp: i32 = a.compare(&b);  // negative (a < b)
  /// ```
  public compare(&self, other: &String): i32 {
    return __string::ignis_string_compare(self, other);
  }

  /// Returns the byte at `index` as a `char`, or `NONE` if out of range.
  ///
  /// This is a byte-level operation: the index is a byte offset, not a
  /// Unicode code point index.
  ///
  /// # Arguments
  ///
  /// * `index` - Zero-based byte offset.
  ///
  /// # Returns
  ///
  /// `Option::SOME(c)` if `index < length`, `Option::NONE` otherwise.
  ///
  /// # Example
  ///
  /// ```ignis
  /// import String from "std::string";
  /// import Option from "std::option";
  ///
  /// let s: String = String::create("abc");
  /// let c: Option<char> = s.charAt(1);  // Option::SOME('b')
  /// let oob: Option<char> = s.charAt(99);  // Option::NONE
  /// ```
  public charAt(&self, index: u64): Option<char> {
    if (index < self.len) {
      return Option::SOME(__string::ignis_string_char_at(self, index));
    }

    return Option::NONE;
  }

  /// Returns the byte index of the first occurrence of `needle`, or `NONE`.
  ///
  /// # Arguments
  ///
  /// * `needle` - The substring to search for.
  ///
  /// # Returns
  ///
  /// `Option::SOME(index)` with the byte offset of the first match, or
  /// `Option::NONE` if `needle` is not found.
  ///
  /// # Example
  ///
  /// ```ignis
  /// import String from "std::string";
  /// import Option from "std::option";
  ///
  /// let s: String = String::create("hello world");
  /// let needle: String = String::create("world");
  /// let idx: Option<u64> = s.indexOf(&needle);  // Option::SOME(6)
  /// ```
  public indexOf(&self, needle: &String): Option<u64> {
    let result: i64 = __string::ignis_string_index_of(self, needle);

    if (result >= 0) {
      return Option::SOME(result as u64);
    }

    return Option::NONE;
  }

  /// Returns `true` if `needle` appears anywhere in this string.
  ///
  /// # Arguments
  ///
  /// * `needle` - The substring to search for.
  ///
  /// # Example
  ///
  /// ```ignis
  /// import String from "std::string";
  ///
  /// let s: String = String::create("hello world");
  /// let needle: String = String::create("world");
  /// let found: boolean = s.contains(&needle);  // true
  /// ```
  public contains(&self, needle: &String): boolean {
    return __string::ignis_string_contains(self, needle);
  }

  /// Returns an immutable `str` view (C `const char*`) of this string's data.
  ///
  /// The returned `str` borrows the String's buffer. It is valid as long
  /// as the String is alive and not mutated.
  ///
  /// # Example
  ///
  /// ```ignis
  /// import String from "std::string";
  ///
  /// let s: String = String::create("hello");
  /// let view: str = s.toStr();  // "hello"
  /// ```
  public toStr(&self): str {
    return __string::ignis_string_cstr(self);
  }

  // ---------------------------------------------------------------------------
  // Instance methods — creating new strings
  // ---------------------------------------------------------------------------

  /// Returns a new string that is the concatenation of `self` and `other`.
  ///
  /// Neither operand is modified. The caller owns the returned String.
  ///
  /// # Arguments
  ///
  /// * `other` - The string to append after `self`.
  ///
  /// # Example
  ///
  /// ```ignis
  /// import String from "std::string";
  ///
  /// let a: String = String::create("hello");
  /// let b: String = String::create(" world");
  /// let msg: String = a.concat(&b);  // "hello world"
  /// ```
  public concat(&self, other: &String): String {
    let mut result: String = String { data: null, len: 0, cap: 0 };
    __string::ignis_string_init_concat(&mut result, self, other);
    return result;
  }

  /// Returns a new string containing `length` bytes starting at byte
  /// offset `start`.
  ///
  /// # Arguments
  ///
  /// * `start`  - Zero-based byte offset to begin extraction.
  /// * `length` - Number of bytes to extract.
  ///
  /// # Example
  ///
  /// ```ignis
  /// import String from "std::string";
  ///
  /// let s: String = String::create("hello world");
  /// let sub: String = s.substring(6, 5);  // "world"
  /// ```
  public substring(&self, start: i64, length: i64): String {
    let mut result: String = String { data: null, len: 0, cap: 0 };
    __string::ignis_string_init_substring(&mut result, self, start, length);
    return result;
  }

  /// Returns a new string with all ASCII lowercase bytes converted to
  /// uppercase. Non-ASCII bytes are copied unchanged.
  ///
  /// # Example
  ///
  /// ```ignis
  /// import String from "std::string";
  ///
  /// let s: String = String::create("Hello");
  /// let upper: String = s.toUpperCase();  // "HELLO"
  /// ```
  public toUpperCase(&self): String {
    let mut result: String = String { data: null, len: 0, cap: 0 };
    __string::ignis_string_init_to_upper(&mut result, self);
    return result;
  }

  /// Returns a new string with all ASCII uppercase bytes converted to
  /// lowercase. Non-ASCII bytes are copied unchanged.
  ///
  /// # Example
  ///
  /// ```ignis
  /// import String from "std::string";
  ///
  /// let s: String = String::create("Hello");
  /// let lower: String = s.toLowerCase();  // "hello"
  /// ```
  public toLowerCase(&self): String {
    let mut result: String = String { data: null, len: 0, cap: 0 };
    __string::ignis_string_init_to_lower(&mut result, self);
    return result;
  }

  /// Creates a deep copy of this string.
  ///
  /// Allocates a new buffer and copies all bytes. The returned String
  /// is completely independent from `self`.
  ///
  /// # Example
  ///
  /// ```ignis
  /// import String from "std::string";
  ///
  /// let original: String = String::create("hello");
  /// let copy: String = original.clone();
  /// // original and copy are independent heap allocations
  /// ```
  public clone(&self): String {
    let mut result: String = String { data: null, len: 0, cap: 0 };
    __string::ignis_string_init_clone(&mut result, self);
    return result;
  }

  // ---------------------------------------------------------------------------
  // Instance methods — mutating
  // ---------------------------------------------------------------------------

  /// Appends a single character (byte) to the end of this string.
  ///
  /// May trigger a reallocation if the buffer is full.
  ///
  /// # Arguments
  ///
  /// * `c` - The character to append.
  ///
  /// # Example
  ///
  /// ```ignis
  /// import String from "std::string";
  ///
  /// let mut s: String = String::create("ab");
  /// s.pushChar('c');  // s is now "abc"
  /// ```
  public pushChar(&mut self, c: char): void {
    __string::ignis_string_push_char(self, c);
  }

  /// Appends a `str` literal to the end of this string.
  ///
  /// # Arguments
  ///
  /// * `s` - The `str` slice to append.
  ///
  /// # Example
  ///
  /// ```ignis
  /// import String from "std::string";
  ///
  /// let mut s: String = String::new();
  /// s.pushStr("hello");
  /// s.pushStr(" world");
  /// // s is now "hello world"
  /// ```
  public pushStr(&mut self, s: str): void {
    __string::ignis_string_push_cstr(self, s);
  }

  /// Appends the contents of another `String` to this string.
  ///
  /// # Arguments
  ///
  /// * `other` - The String whose bytes are appended.
  ///
  /// # Example
  ///
  /// ```ignis
  /// import String from "std::string";
  ///
  /// let mut s: String = String::create("hello");
  /// let suffix: String = String::create(" world");
  /// s.push(&suffix);
  /// // s is now "hello world"
  /// ```
  public push(&mut self, other: &String): void {
    __string::ignis_string_push_str(self, other);
  }

  /// Resets the string length to 0 without releasing the backing buffer.
  ///
  /// Subsequent pushes reuse the existing capacity.
  ///
  /// # Example
  ///
  /// ```ignis
  /// import String from "std::string";
  ///
  /// let mut s: String = String::create("hello");
  /// s.clear();
  /// // s.length() == 0, but capacity is still available
  /// ```
  public clear(&mut self): void {
    __string::ignis_string_clear(self);
  }

  /// Ensures the buffer has room for at least `additional` more bytes
  /// beyond the current length.
  ///
  /// If the current capacity is already sufficient, this is a no-op.
  /// Otherwise the buffer is reallocated.
  ///
  /// # Arguments
  ///
  /// * `additional` - Number of extra bytes to guarantee.
  ///
  /// # Example
  ///
  /// ```ignis
  /// import String from "std::string";
  ///
  /// let mut s: String = String::new();
  /// s.reserve(1024);
  /// // s can now hold at least 1024 bytes without reallocation
  /// ```
  public reserve(&mut self, additional: u64): void {
    __string::ignis_string_reserve(self, additional);
  }

  // ---------------------------------------------------------------------------
  // Higher-order byte methods
  // ---------------------------------------------------------------------------

  /// Calls `callback` once for each byte in the string, in order.
  ///
  /// The callback receives the raw byte value (`u8`), not a character
  /// reference. This is useful for byte-level inspection or accumulation.
  ///
  /// # Arguments
  ///
  /// * `callback` - Function invoked with each byte value.
  ///
  /// # Example
  ///
  /// ```ignis
  /// import String from "std::string";
  ///
  /// let s: String = String::create("abc");
  ///
  /// // Print each byte value (97, 98, 99)
  /// s.forEachByte(|b: u8| -> void {
  ///   Io::printU8(b);
  /// });
  /// ```
  public forEachByte(&self, @noescape callback: (u8) -> void): void {
    let mut i: u64 = 0;

    while (i < self.len) {
      callback(self.data[i]);
      i += 1;
    }
  }

  /// Returns the byte index of the first byte for which `predicate`
  /// returns `true`, or `Option::NONE` if no byte matches.
  ///
  /// Short-circuits: stops scanning at the first match.
  ///
  /// # Arguments
  ///
  /// * `predicate` - Callback that receives a byte and returns `true`
  ///   to indicate a match.
  ///
  /// # Returns
  ///
  /// `Option::SOME(index)` for the first matching byte, or `Option::NONE`.
  ///
  /// # Example
  ///
  /// ```ignis
  /// import String from "std::string";
  /// import Option from "std::option";
  ///
  /// let s: String = String::create("hello world");
  ///
  /// // Find the first space (byte 32)
  /// let idx: Option<u64> = s.findByte(|b: u8| -> boolean { return b == 32; });
  /// // idx == Option::SOME(5)
  ///
  /// // Find a byte that doesn't exist
  /// let missing: Option<u64> = s.findByte(|b: u8| -> boolean { return b == 0; });
  /// // missing == Option::NONE
  /// ```
  public findByte(&self, @noescape predicate: (u8) -> boolean): Option<u64> {
    let mut i: u64 = 0;

    while (i < self.len) {
      if (predicate(self.data[i])) {
        return Option::SOME(i);
      }
      i += 1;
    }

    return Option::NONE;
  }

  /// Returns a new string with leading and trailing bytes stripped
  /// where `predicate` returns `true`.
  ///
  /// Scans inward from both ends, removing bytes as long as the predicate
  /// matches. Returns an empty string if all bytes are stripped.
  ///
  /// # Arguments
  ///
  /// * `predicate` - Callback that receives a byte and returns `true` to
  ///   strip it.
  ///
  /// # Returns
  ///
  /// A new `String` with the outer matching bytes removed. The original
  /// string is unchanged.
  ///
  /// # How It Works
  ///
  /// ```text
  ///   "  hello  "  with predicate: b == 32 (space)
  ///
  ///   Step 1 — scan from left:
  ///   [ ][  ][h][e][l][l][o][ ][ ]
  ///    ^  ^                          ← strip (space)
  ///          ^                       ← stop (not space)
  ///   start = 2
  ///
  ///   Step 2 — scan from right:
  ///   [ ][ ][h][e][l][l][o][ ][ ]
  ///                          ^  ^   ← strip (space)
  ///                       ^         ← stop (not space)
  ///   end = 6
  ///
  ///   Result: substring(2, 5) → "hello"
  /// ```
  ///
  /// # Example
  ///
  /// ```ignis
  /// import String from "std::string";
  ///
  /// let s: String = String::create("  hello  ");
  ///
  /// // Trim spaces (byte 32)
  /// let trimmed: String = s.trimWhere(|b: u8| -> boolean { return b == 32; });
  /// // trimmed == "hello"
  ///
  /// // Trim tabs and spaces
  /// let mixed: String = String::create("\t hello \t");
  /// let clean: String = mixed.trimWhere(|b: u8| -> boolean {
  ///   return b == 32 || b == 9;
  /// });
  /// // clean == "hello"
  /// ```
  public trimWhere(&self, @noescape predicate: (u8) -> boolean): String {
    let mut start: u64 = 0;
    while (start < self.len && predicate(self.data[start])) {
      start += 1;
    }

    let mut end: i64 = self.len as i64 - 1;
    while (end >= start as i64 && predicate(self.data[end as u64])) {
      end -= 1;
    }

    let trimLen: i64 = end - start as i64 + 1;
    if (trimLen <= 0) {
      return String::new();
    }

    return self.substring(start as i64, trimLen);
  }

  /// Splits the string at each byte where `predicate` returns `true`.
  ///
  /// The matching (separator) bytes are **not** included in the resulting
  /// segments. Adjacent separators produce empty strings. A trailing
  /// separator produces a trailing empty string.
  ///
  /// # Arguments
  ///
  /// * `predicate` - Callback that receives a byte and returns `true` at
  ///   split points.
  ///
  /// # Returns
  ///
  /// A `Vector<String>` of segments. The caller owns the vector and all
  /// the strings within it.
  ///
  /// # How It Works
  ///
  /// ```text
  ///   "a,b,,c"  with predicate: b == 44 (comma)
  ///
  ///    a , b , , c
  ///    ^         ← segment "a"
  ///      ^       ← split
  ///        ^     ← segment "b"
  ///          ^   ← split
  ///            ^ ← split (empty segment "")
  ///              ^← segment "c"
  ///
  ///   Result: ["a", "b", "", "c"]
  /// ```
  ///
  /// # Example
  ///
  /// ```ignis
  /// import String from "std::string";
  /// import Vector from "std::vector";
  ///
  /// let csv: String = String::create("alice,bob,charlie");
  ///
  /// // Split on commas (byte 44)
  /// let parts: Vector<String> = csv.split(|b: u8| -> boolean {
  ///   return b == 44;
  /// });
  /// // parts: ["alice", "bob", "charlie"]
  ///
  /// // Split on spaces
  /// let words: String = String::create("hello world foo");
  /// let tokens: Vector<String> = words.split(|b: u8| -> boolean {
  ///   return b == 32;
  /// });
  /// // tokens: ["hello", "world", "foo"]
  /// ```
  public split(&self, @noescape predicate: (u8) -> boolean): Vector<String> {
    let mut result: Vector<String> = Vector::init<String>();
    let mut start: u64 = 0;
    let mut i: u64 = 0;

    while (i < self.len) {
      if (predicate(self.data[i])) {
        if (i > start) {
          result.push(self.substring(start as i64, (i - start) as i64));
        } else {
          result.push(String::new());
        }
        start = i + 1;
      }
      i += 1;
    }

    // Trailing segment
    if (start <= self.len) {
      if (start < self.len) {
        result.push(self.substring(start as i64, (self.len - start) as i64));
      } else {
        result.push(String::new());
      }
    }

    return result;
  }

  // ---------------------------------------------------------------------------
  // Drop
  // ---------------------------------------------------------------------------

  /// Releases the backing byte buffer and resets all fields.
  ///
  /// Called automatically when the String goes out of scope via
  /// `@implements(Drop)`. Can also be called manually to release
  /// memory early.
  public drop(&mut self): void {
    __string::ignis_string_drop(self);
  }
}

// =============================================================================
// Extension methods — toString on primitive types
// =============================================================================

/// Converts an `i8` to an owned String.
@extension(i8)
function toString(value: i8): String { return String::create(value); }

/// Converts an `i16` to an owned String.
@extension(i16)
function toString(value: i16): String { return String::create(value); }

/// Converts an `i32` to an owned String.
@extension(i32)
function toString(value: i32): String { return String::create(value); }

/// Converts an `i64` to an owned String.
@extension(i64)
function toString(value: i64): String { return String::create(value); }

/// Converts a `u8` to an owned String.
@extension(u8)
function toString(value: u8): String { return String::create(value); }

/// Converts a `u16` to an owned String.
@extension(u16)
function toString(value: u16): String { return String::create(value); }

/// Converts a `u32` to an owned String.
@extension(u32)
function toString(value: u32): String { return String::create(value); }

/// Converts a `u64` to an owned String.
@extension(u64)
function toString(value: u64): String { return String::create(value); }

/// Converts an `f32` to an owned String.
@extension(f32)
function toString(value: f32): String { return String::create(value); }

/// Converts an `f64` to an owned String.
@extension(f64)
function toString(value: f64): String { return String::create(value); }

/// Converts a boolean to `"true"` or `"false"`.
@extension(boolean)
function toString(value: boolean): String { return value ? String::create("true") : String::create("false"); }

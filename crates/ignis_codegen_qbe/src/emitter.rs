use std::collections::{HashMap, HashSet, VecDeque};
use std::fmt::Write;

use ignis_codegen_c::mangle_symbol_name;
use ignis_hir::operation::{BinaryOperation, UnaryOperation};
use ignis_lir::{ConstValue, FunctionLir, Instr, LirProgram, Operand, Terminator};
use ignis_type::{
  definition::{DefinitionId, DefinitionKind, DefinitionStore},
  namespace::NamespaceStore,
  symbol::SymbolTable,
  types::{Type, TypeId, TypeStore},
};

use crate::errors::QbeError;

#[derive(Debug, Clone)]
pub struct QbeEmitOptions {
  pub export_all_functions: bool,
}

impl Default for QbeEmitOptions {
  fn default() -> Self {
    Self {
      export_all_functions: true,
    }
  }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum ScalarKind {
  W,
  L,
}

impl ScalarKind {
  fn abi(self) -> &'static str {
    match self {
      ScalarKind::W => "w",
      ScalarKind::L => "l",
    }
  }

  fn store_op(self) -> &'static str {
    match self {
      ScalarKind::W => "storew",
      ScalarKind::L => "storel",
    }
  }

  fn load_op(self) -> &'static str {
    match self {
      ScalarKind::W => "loadw",
      ScalarKind::L => "loadl",
    }
  }

}

pub fn emit_qbe(
  program: &LirProgram,
  types: &TypeStore,
  defs: &DefinitionStore,
  namespaces: &NamespaceStore,
  symbols: &SymbolTable,
  options: &QbeEmitOptions,
) -> Result<String, QbeError> {
  let mut emitter = QbeEmitter {
    program,
    types,
    defs,
    namespaces,
    symbols,
    options,
    output: String::new(),
    string_literals: Vec::new(),
    next_string_id: 0,
    type_sizes: HashMap::new(),
    drop_glue_types: Vec::new(),
    next_aux_tmp: 0,
  };

  emitter.emit_program()?;

  Ok(emitter.output)
}

struct QbeEmitter<'a> {
  program: &'a LirProgram,
  types: &'a TypeStore,
  defs: &'a DefinitionStore,
  namespaces: &'a NamespaceStore,
  symbols: &'a SymbolTable,
  options: &'a QbeEmitOptions,
  output: String,
  string_literals: Vec<(String, String)>,
  next_string_id: u32,
  type_sizes: HashMap<TypeId, u64>,
  drop_glue_types: Vec<TypeId>,
  next_aux_tmp: u32,
}

impl<'a> QbeEmitter<'a> {
  fn emit_program(&mut self) -> Result<(), QbeError> {
    writeln!(self.output, "# generated by Ignis QBE backend").unwrap();

    let reachable = self.compute_reachable_functions();

    let mut functions: Vec<_> = self
      .program
      .functions
      .iter()
      .filter(|(def_id, _)| reachable.contains(def_id))
      .collect();
    functions.sort_by_key(|(def_id, _)| def_id.index());

    for (index, (def_id, function)) in functions.iter().enumerate() {
      if function.is_extern || function.is_variadic {
        continue;
      }

      if !self.is_function_signature_monomorphized(function) {
        continue;
      }

      if index > 0 {
        writeln!(self.output).unwrap();
      }

      self.emit_function(**def_id, function)?;
    }

    self.emit_drop_glue_functions()?;

    if !self.string_literals.is_empty() {
      writeln!(self.output).unwrap();
      writeln!(self.output, "# string data").unwrap();

      for (label, value) in &self.string_literals {
        let escaped = qbe_escape_string(value);
        writeln!(self.output, "data ${} = {{ b \"{}\", b 0 }}", label, escaped).unwrap();
      }
    }

    Ok(())
  }

  fn emit_function(
    &mut self,
    def_id: DefinitionId,
    function: &FunctionLir,
  ) -> Result<(), QbeError> {
    let function_name = self.def_name(def_id);
    let return_abi = self.return_abi_for_type(function.return_type)?;

    let mut params = Vec::with_capacity(function.params.len());
    for (param_index, param_id) in function.params.iter().enumerate() {
      let param_type = *self.defs.type_of(param_id);
      let param_abi = self.abi_for_type(param_type, "function parameter")?;
      params.push(format!("{} %p{}", param_abi, param_index));
    }

    let export_prefix = if self.options.export_all_functions || self.program.entry_point == Some(def_id) {
      "export "
    } else {
      ""
    };

    let params_joined = if params.is_empty() {
      "".to_string()
    } else {
      params.join(", ")
    };

    match return_abi {
      Some(abi) => {
        writeln!(self.output, "{}function {} ${}({}) {{", export_prefix, abi, function_name, params_joined).unwrap();
      },
      None => {
        writeln!(self.output, "{}function ${}({}) {{", export_prefix, function_name, params_joined).unwrap();
      },
    }

    let block_labels: Vec<String> = function
      .blocks
      .get_all()
      .iter()
      .map(|block| sanitize_label(&block.label))
      .collect();

    for (block_index, block) in function.blocks.get_all().iter().enumerate() {
      writeln!(self.output, "@{}", block_labels[block_index]).unwrap();

      if block_index == 0 {
        self.emit_local_allocations(function)?;
      }

      for (instruction_index, instruction) in block.instructions.iter().enumerate() {
        self.emit_instruction(
          def_id,
          &function_name,
          &block_labels[block_index],
          function,
          instruction,
          instruction_index,
        )?;
      }

      self.emit_terminator(def_id, &function_name, function, &block_labels, &block.terminator)?;
    }

    writeln!(self.output, "}}").unwrap();

    Ok(())
  }

  fn emit_local_allocations(
    &mut self,
    function: &FunctionLir,
  ) -> Result<(), QbeError> {
    for (index, local) in function.locals.get_all().iter().enumerate() {
      let size = self.sizeof_type(local.ty);
      let align = self.alignof_type(local.ty);
      let alloc_op = match align {
        a if a <= 4 => "alloc4",
        a if a <= 8 => "alloc8",
        _ => "alloc16",
      };

      writeln!(
        self.output,
        "    %l{} =l {} {}",
        index,
        alloc_op,
        size
      )
      .unwrap();
    }

    Ok(())
  }

  fn emit_instruction(
    &mut self,
    def_id: DefinitionId,
    function_name: &str,
    block_label: &str,
    function: &FunctionLir,
    instruction: &Instr,
    instruction_index: usize,
  ) -> Result<(), QbeError> {
    match instruction {
      Instr::Load { dest, source } => {
        let kind = self.scalar_kind_for_temp(function, *dest, "load destination")?;
        writeln!(
          self.output,
          "    {} ={} {} %l{}",
          self.temp_name(function, *dest),
          kind.abi(),
          kind.load_op(),
          source.index()
        )
        .unwrap();
      },
      Instr::Store { dest, value } => {
        let local_type = function.locals.get(dest).ty;
        let kind = self.scalar_kind_for_type(local_type, "store local")?;
        let value_text = self.format_operand(function, value, Some(kind), "store")?;

        writeln!(
          self.output,
          "    {} {}, %l{}",
          kind.store_op(),
          value_text,
          dest.index()
        )
        .unwrap();
      },
      Instr::Copy { dest, source } => {
        let kind = self.scalar_kind_for_temp(function, *dest, "copy destination")?;
        let source_text = self.format_operand(function, source, Some(kind), "copy")?;

        writeln!(
          self.output,
          "    {} ={} copy {}",
          self.temp_name(function, *dest),
          kind.abi(),
          source_text
        )
        .unwrap();
      },
      Instr::BinOp {
        dest,
        op,
        left,
        right,
      } => {
        self.emit_binop(function, *dest, op, left, right)?;
      },
      Instr::UnaryOp { dest, op, operand } => {
        self.emit_unary(function, *dest, op, operand)?;
      },
      Instr::Cast {
        dest,
        source,
        target_type,
      } => {
        self.emit_cast(function, *dest, source, *target_type)?;
      },
      Instr::Call { dest, callee, args } => {
        self.emit_call(function, *dest, *callee, args)?;
      },
      Instr::LoadPtr { dest, ptr } => {
        let kind = self.scalar_kind_for_temp(function, *dest, "loadptr destination")?;
        let ptr_text = self.format_operand(function, ptr, Some(ScalarKind::L), "loadptr")?;

        writeln!(
          self.output,
          "    {} ={} {} {}",
          self.temp_name(function, *dest),
          kind.abi(),
          kind.load_op(),
          ptr_text
        )
        .unwrap();
      },
      Instr::StorePtr { ptr, value } => {
        let ptr_text = self.format_operand(function, ptr, Some(ScalarKind::L), "storeptr ptr")?;

        let value_kind = self
          .operand_type(function, value)
          .and_then(|ty| self.scalar_kind_for_type(ty, "storeptr value").ok())
          .unwrap_or(ScalarKind::L);
        let value_text = self.format_operand(function, value, Some(value_kind), "storeptr value")?;

        writeln!(
          self.output,
          "    {} {}, {}",
          value_kind.store_op(),
          value_text,
          ptr_text
        )
        .unwrap();
      },
      Instr::BuiltinLoad { dest, ptr, ty } => {
        let kind = self.scalar_kind_for_type(*ty, "builtin load")?;
        let ptr_text = self.format_operand(function, ptr, Some(ScalarKind::L), "builtin load ptr")?;

        writeln!(
          self.output,
          "    {} ={} {} {}",
          self.temp_name(function, *dest),
          kind.abi(),
          kind.load_op(),
          ptr_text
        )
        .unwrap();
      },
      Instr::BuiltinStore { ptr, value, ty } => {
        let kind = self.scalar_kind_for_type(*ty, "builtin store")?;
        let ptr_text = self.format_operand(function, ptr, Some(ScalarKind::L), "builtin store ptr")?;
        let value_text = self.format_operand(function, value, Some(kind), "builtin store value")?;

        writeln!(
          self.output,
          "    {} {}, {}",
          kind.store_op(),
          value_text,
          ptr_text
        )
        .unwrap();
      },
      Instr::AddrOfLocal { dest, local, .. } => {
        writeln!(
          self.output,
          "    {} =l copy %l{}",
          self.temp_name(function, *dest),
          local.index()
        )
        .unwrap();
      },
      Instr::GetElementPtr {
        dest,
        base,
        index,
        element_type,
      } => {
        let base_text = self.format_operand(function, base, Some(ScalarKind::L), "gep base")?;
        let index_text = self.format_operand(function, index, Some(ScalarKind::L), "gep index")?;
        let elem_size = self.sizeof_type(*element_type);

        let offset_tmp = format!("%qgep_off{}", dest.index());
        let scaled_tmp = format!("%qgep_sc{}", dest.index());

        writeln!(self.output, "    {} =l extsw {}", offset_tmp, index_text).unwrap();
        writeln!(self.output, "    {} =l mul {}, {}", scaled_tmp, offset_tmp, elem_size).unwrap();
        writeln!(
          self.output,
          "    {} =l add {}, {}",
          self.temp_name(function, *dest),
          base_text,
          scaled_tmp
        )
        .unwrap();
      },
      Instr::GetFieldPtr {
        dest,
        base,
        field_index,
        field_type: _,
      } => {
        let base_text = self.format_operand(function, base, Some(ScalarKind::L), "getfieldptr base")?;
        let base_type = self.operand_type(function, base);

        let record_type = base_type.and_then(|ty| match self.types.get(&ty) {
          Type::Pointer { inner, .. } | Type::Reference { inner, .. } => Some(*inner),
          Type::Record(_) | Type::Enum(_) => Some(ty),
          _ => Some(ty),
        });

        let offset = record_type
          .map(|rt| self.field_offset(rt, *field_index))
          .unwrap_or((*field_index as u64) * 8);

        if offset == 0 {
          writeln!(
            self.output,
            "    {} =l copy {}",
            self.temp_name(function, *dest),
            base_text
          )
          .unwrap();
        } else {
          writeln!(
            self.output,
            "    {} =l add {}, {}",
            self.temp_name(function, *dest),
            base_text,
            offset
          )
          .unwrap();
        }
      },
      Instr::InitRecord {
        dest_ptr,
        fields,
        record_type,
      } => {
        let ptr_text = self.format_operand(function, dest_ptr, Some(ScalarKind::L), "initrecord ptr")?;

        for (field_idx, field_value) in fields {
          let offset = self.field_offset(*record_type, *field_idx);
          let field_ty = self.record_field_type(*record_type, *field_idx);

          let kind = field_ty
            .and_then(|ty| self.scalar_kind_for_type(ty, "initrecord field").ok())
            .unwrap_or(ScalarKind::L);
          let value_text = self.format_operand(function, field_value, Some(kind), "initrecord field value")?;

          if offset == 0 {
            writeln!(self.output, "    {} {}, {}", kind.store_op(), value_text, ptr_text).unwrap();
          } else {
            let field_ptr_tmp = format!("%qir_fp{}_{}", field_idx, instruction_index);
            writeln!(self.output, "    {} =l add {}, {}", field_ptr_tmp, ptr_text, offset).unwrap();
            writeln!(self.output, "    {} {}, {}", kind.store_op(), value_text, field_ptr_tmp).unwrap();
          }
        }
      },
      Instr::InitEnumVariant {
        dest_ptr,
        enum_type,
        variant_tag,
        payload,
      } => {
        let ptr_text = self.format_operand(function, dest_ptr, Some(ScalarKind::L), "initenumvariant ptr")?;

        writeln!(self.output, "    storew {}, {}", variant_tag, ptr_text).unwrap();

        let payload_base_offset = self.enum_payload_offset(*enum_type);

        for (i, payload_value) in payload.iter().enumerate() {
          let payload_field_offset = payload_base_offset + (i as u64) * 8;
          let kind = self
            .operand_type(function, payload_value)
            .and_then(|ty| self.scalar_kind_for_type(ty, "initenumvariant payload").ok())
            .unwrap_or(ScalarKind::L);
          let value_text = self.format_operand(function, payload_value, Some(kind), "initenumvariant payload")?;

          let field_ptr_tmp = format!("%qev_fp{}_{}", i, instruction_index);
          writeln!(self.output, "    {} =l add {}, {}", field_ptr_tmp, ptr_text, payload_field_offset).unwrap();
          writeln!(self.output, "    {} {}, {}", kind.store_op(), value_text, field_ptr_tmp).unwrap();
        }
      },
      Instr::EnumGetTag { dest, source } => {
        let source_text = self.format_operand(function, source, Some(ScalarKind::L), "enumgettag")?;

        writeln!(
          self.output,
          "    {} =w loadw {}",
          self.temp_name(function, *dest),
          source_text
        )
        .unwrap();
      },
      Instr::EnumGetPayloadField {
        dest,
        source,
        variant_tag: _,
        field_index,
      } => {
        let source_text = self.format_operand(function, source, Some(ScalarKind::L), "enumgetpayloadfield")?;
        let source_type = self.operand_type(function, source);
        let enum_type = source_type.unwrap_or_else(|| {
          function.temp_type(*dest)
        });

        let payload_base_offset = self.enum_payload_offset(enum_type);
        let field_offset = payload_base_offset + (*field_index as u64) * 8;

        let kind = self.scalar_kind_for_temp(function, *dest, "enumgetpayloadfield dest")?;

        let field_ptr_tmp = format!("%qegpf{}", dest.index());
        writeln!(self.output, "    {} =l add {}, {}", field_ptr_tmp, source_text, field_offset).unwrap();
        writeln!(
          self.output,
          "    {} ={} {} {}",
          self.temp_name(function, *dest),
          kind.abi(),
          kind.load_op(),
          field_ptr_tmp
        )
        .unwrap();
      },
      Instr::InitVector {
        dest_ptr,
        elements,
        element_type,
      } => {
        let ptr_text = self.format_operand(function, dest_ptr, Some(ScalarKind::L), "initvector ptr")?;
        let elem_size = self.sizeof_type(*element_type);
        let kind = self
          .scalar_kind_for_type(*element_type, "initvector element")
          .unwrap_or(ScalarKind::L);

        for (i, elem) in elements.iter().enumerate() {
          let value_text = self.format_operand(function, elem, Some(kind), "initvector element")?;
          let offset = (i as u64) * elem_size;

          if offset == 0 {
            writeln!(self.output, "    {} {}, {}", kind.store_op(), value_text, ptr_text).unwrap();
          } else {
            let elem_ptr_tmp = format!("%qiv_ep{}_{}", i, instruction_index);
            writeln!(self.output, "    {} =l add {}, {}", elem_ptr_tmp, ptr_text, offset).unwrap();
            writeln!(self.output, "    {} {}, {}", kind.store_op(), value_text, elem_ptr_tmp).unwrap();
          }
        }
      },
      Instr::BitCast {
        dest,
        source,
        target_type,
      } => {
        let source_text = self.format_operand(function, source, None, "bitcast source")?;
        let dest_kind = self.scalar_kind_for_type(*target_type, "bitcast dest").unwrap_or(ScalarKind::L);

        writeln!(
          self.output,
          "    {} ={} copy {}",
          self.temp_name(function, *dest),
          dest_kind.abi(),
          source_text
        )
        .unwrap();
      },
      Instr::SizeOf { dest, ty } => {
        let size = self.sizeof_type(*ty);
        let dest_kind = self.scalar_kind_for_temp(function, *dest, "sizeof dest")?;

        writeln!(
          self.output,
          "    {} ={} copy {}",
          self.temp_name(function, *dest),
          dest_kind.abi(),
          size
        )
        .unwrap();
      },
      Instr::AlignOf { dest, ty } => {
        let align = self.alignof_type(*ty);
        let dest_kind = self.scalar_kind_for_temp(function, *dest, "alignof dest")?;

        writeln!(
          self.output,
          "    {} ={} copy {}",
          self.temp_name(function, *dest),
          dest_kind.abi(),
          align
        )
        .unwrap();
      },
      Instr::MaxOf { dest, ty } => {
        let max_val = self.type_max_value(*ty);
        let dest_kind = self.scalar_kind_for_temp(function, *dest, "maxof dest")?;

        writeln!(
          self.output,
          "    {} ={} copy {}",
          self.temp_name(function, *dest),
          dest_kind.abi(),
          max_val
        )
        .unwrap();
      },
      Instr::MinOf { dest, ty } => {
        let min_val = self.type_min_value(*ty);
        let dest_kind = self.scalar_kind_for_temp(function, *dest, "minof dest")?;

        writeln!(
          self.output,
          "    {} ={} copy {}",
          self.temp_name(function, *dest),
          dest_kind.abi(),
          min_val
        )
        .unwrap();
      },
      Instr::Trap { .. } => {
        writeln!(self.output, "    call $abort()").unwrap();
        writeln!(self.output, "    hlt").unwrap();
      },
      Instr::PanicMessage { message, .. } => {
        let label = self.intern_string(message);
        writeln!(self.output, "    call $ignis_panic_msg(l ${}, w {})", label, message.len()).unwrap();
        writeln!(self.output, "    hlt").unwrap();
      },
      Instr::RuntimeCall { name, args } => {
        let mut arg_texts = Vec::with_capacity(args.len());

        for arg in args {
          let kind = self
            .operand_type(function, arg)
            .and_then(|ty| self.scalar_kind_for_type(ty, "runtimecall arg").ok())
            .unwrap_or(ScalarKind::L);
          let value_text = self.format_operand(function, arg, Some(kind), "runtimecall arg")?;
          arg_texts.push(format!("{} {}", kind.abi(), value_text));
        }

        writeln!(self.output, "    call ${}({})", name, arg_texts.join(", ")).unwrap();
      },
      Instr::Drop { local } => {
        let local_data = function.locals.get(local);
        let ty = local_data.ty;
        let local_ptr = format!("%l{}", local.index());
        self.emit_field_drops_qbe(&local_ptr, ty)?;
      },
      Instr::DropInPlace { ptr, ty } => {
        if self.types.needs_drop_with_defs(ty, self.defs) {
          let ptr_text = self.format_operand(function, ptr, Some(ScalarKind::L), "dropinplace")?;
          self.emit_field_drops_qbe(&ptr_text, *ty)?;
        } else {
          writeln!(self.output, "    # drop_in_place: no-op").unwrap();
        }
      },
      Instr::DropGlue { dest, ty } => {
        let glue_name = self.drop_glue_name(*ty);
        self.drop_glue_types.push(*ty);
        writeln!(
          self.output,
          "    {} =l copy ${}",
          self.temp_name(function, *dest),
          glue_name
        )
        .unwrap();
      },
      Instr::TypeIdOf { dest, .. } => {
        writeln!(
          self.output,
          "    {} =l copy 0  # typeIdOf stub",
          self.temp_name(function, *dest)
        )
        .unwrap();
      },
      Instr::MakeClosure {
        dest,
        thunk,
        drop_fn,
        captures,
        closure_type: _,
        heap_allocate,
      } => {
        self.emit_make_closure(function, *dest, *thunk, drop_fn.as_ref().copied(), captures, *heap_allocate)?;
      },
      Instr::CallClosure {
        dest,
        closure,
        args,
        return_type,
      } => {
        self.emit_call_closure(function, *dest, closure, args, *return_type)?;
      },
      Instr::DropClosure {
        closure,
        closure_type: _,
        heap_allocated,
      } => {
        self.emit_drop_closure(function, closure, *heap_allocated)?;
      },
      Instr::Nop => {
        writeln!(self.output, "    # nop").unwrap();
      },
    }

    let _ = (def_id, function_name, block_label);

    Ok(())
  }

  fn emit_binop(
    &mut self,
    function: &FunctionLir,
    dest: ignis_lir::TempId,
    op: &BinaryOperation,
    left: &Operand,
    right: &Operand,
  ) -> Result<(), QbeError> {
    let dest_kind = self.scalar_kind_for_temp(function, dest, "binop destination")?;
    let left_kind = self.scalar_kind_for_operand(function, left, "binop left operand")?;

    let left_text = self.format_operand(function, left, Some(left_kind), "binop left")?;
    let right_text = self.format_operand(function, right, Some(left_kind), "binop right")?;

    if let Some(compare_base) = self.compare_opcode_base(function, op, left) {
      let compare_kind = left_kind;
      let compare_opcode = format!("{}{}", compare_base, compare_kind.abi());

      if compare_kind == dest_kind {
        writeln!(
          self.output,
          "    {} ={} {} {}, {}",
          self.temp_name(function, dest),
          dest_kind.abi(),
          compare_opcode,
          left_text,
          right_text
        )
        .unwrap();
      } else {
        let cmp_tmp = format!("%qcmp{}_{}", dest.index(), compare_kind.abi());
        writeln!(
          self.output,
          "    {} ={} {} {}, {}",
          cmp_tmp,
          compare_kind.abi(),
          compare_opcode,
          left_text,
          right_text
        )
        .unwrap();
        writeln!(
          self.output,
          "    {} ={} copy {}",
          self.temp_name(function, dest),
          dest_kind.abi(),
          cmp_tmp
        )
        .unwrap();
      }

      return Ok(());
    }

    let opcode = self.arithmetic_opcode(function, op, left)?;

    writeln!(
      self.output,
      "    {} ={} {} {}, {}",
      self.temp_name(function, dest),
      dest_kind.abi(),
      opcode,
      left_text,
      right_text
    )
    .unwrap();

    Ok(())
  }

  fn emit_unary(
    &mut self,
    function: &FunctionLir,
    dest: ignis_lir::TempId,
    op: &UnaryOperation,
    operand: &Operand,
  ) -> Result<(), QbeError> {
    let dest_kind = self.scalar_kind_for_temp(function, dest, "unary destination")?;
    let operand_kind = self.scalar_kind_for_operand(function, operand, "unary operand")?;
    let operand_text = self.format_operand(function, operand, Some(operand_kind), "unary")?;

    match op {
      UnaryOperation::Neg => {
        writeln!(
          self.output,
          "    {} ={} neg {}",
          self.temp_name(function, dest),
          dest_kind.abi(),
          operand_text
        )
        .unwrap();
      },
      UnaryOperation::BitNot => {
        writeln!(
          self.output,
          "    {} ={} xor {}, -1",
          self.temp_name(function, dest),
          dest_kind.abi(),
          operand_text
        )
        .unwrap();
      },
      UnaryOperation::Not => {
        let compare_opcode = format!("ceq{}", operand_kind.abi());

        if operand_kind == dest_kind {
          writeln!(
            self.output,
            "    {} ={} {} {}, 0",
            self.temp_name(function, dest),
            dest_kind.abi(),
            compare_opcode,
            operand_text
          )
          .unwrap();
        } else {
          let cmp_tmp = format!("%qnot{}_{}", dest.index(), operand_kind.abi());
          writeln!(
            self.output,
            "    {} ={} {} {}, 0",
            cmp_tmp,
            operand_kind.abi(),
            compare_opcode,
            operand_text
          )
          .unwrap();
          writeln!(
            self.output,
            "    {} ={} copy {}",
            self.temp_name(function, dest),
            dest_kind.abi(),
            cmp_tmp
          )
          .unwrap();
        }
      },
    }

    Ok(())
  }

  fn emit_cast(
    &mut self,
    function: &FunctionLir,
    dest: ignis_lir::TempId,
    source: &Operand,
    target_type: TypeId,
  ) -> Result<(), QbeError> {
    let dest_kind = self.scalar_kind_for_type(target_type, "cast destination")?;

    let source_type = self
      .operand_type(function, source)
      .ok_or_else(|| QbeError::unsupported_operand("cast", format!("{:?}", source)))?;
    let source_kind = self.scalar_kind_for_type(source_type, "cast source")?;

    let source_text = self.format_operand(function, source, Some(source_kind), "cast")?;

    if source_kind == dest_kind {
      writeln!(
        self.output,
        "    {} ={} copy {}",
        self.temp_name(function, dest),
        dest_kind.abi(),
        source_text
      )
      .unwrap();
      return Ok(());
    }

    match (source_kind, dest_kind) {
      (ScalarKind::W, ScalarKind::L) => {
        let extend_op = if self.is_unsigned_type(source_type) {
          "extuw"
        } else {
          "extsw"
        };

        writeln!(
          self.output,
          "    {} =l {} {}",
          self.temp_name(function, dest),
          extend_op,
          source_text
        )
        .unwrap();
      },
      (ScalarKind::L, ScalarKind::W) => {
        writeln!(
          self.output,
          "    {} =w copy {}",
          self.temp_name(function, dest),
          source_text
        )
        .unwrap();
      },
      _ => {
        writeln!(
          self.output,
          "    {} ={} copy {}",
          self.temp_name(function, dest),
          dest_kind.abi(),
          source_text
        )
        .unwrap();
      },
    }

    Ok(())
  }

  fn emit_call(
    &mut self,
    function: &FunctionLir,
    dest: Option<ignis_lir::TempId>,
    callee: DefinitionId,
    args: &[Operand],
  ) -> Result<(), QbeError> {
    let callee_name = self.def_name(callee);
    let callee_def = self.defs.get(&callee);

    let (param_ids, return_type, is_variadic) = match &callee_def.kind {
      DefinitionKind::Function(fd) => (fd.params.as_slice(), Some(fd.return_type), fd.is_variadic),
      DefinitionKind::Method(md) => (md.params.as_slice(), Some(md.return_type), false),
      _ => {
        return Err(QbeError::unsupported_instruction(
          callee_name,
          "call".to_string(),
          0,
          format!("call target is not a function: {:?}", callee_def.kind),
        ));
      },
    };

    if !is_variadic && args.len() != param_ids.len() {
      return Err(QbeError::unsupported_instruction(
        self.def_name(function.def_id),
        "call".to_string(),
        0,
        format!(
          "call arity mismatch for {} (expected {}, got {})",
          self.def_name(callee),
          param_ids.len(),
          args.len()
        ),
      ));
    }

    let mut arg_texts = Vec::with_capacity(args.len());
    for (index, arg) in args.iter().enumerate() {
      let arg_type = if index < param_ids.len() {
        *self.defs.type_of(&param_ids[index])
      } else {
        self
          .operand_type(function, arg)
          .ok_or_else(|| QbeError::unsupported_operand("call variadic arg", format!("{:?}", arg)))?
      };

      let arg_kind = self.scalar_kind_for_type(arg_type, "call argument")?;
      let abi = self.abi_for_type(arg_type, "call argument")?;
      let value_text = self.format_operand(function, arg, Some(arg_kind), "call argument")?;
      arg_texts.push(format!("{} {}", abi, value_text));
    }

    let call_text = format!("call ${}({})", self.def_name(callee), arg_texts.join(", "));

    match dest {
      Some(dest_temp) => {
        let dest_kind = self.scalar_kind_for_temp(function, dest_temp, "call destination")?;

        let ret_type = return_type.ok_or_else(|| {
          QbeError::unsupported_instruction(
            self.def_name(function.def_id),
            "call".to_string(),
            0,
            "destination temp used for void-return call".to_string(),
          )
        })?;

        let ret_kind = self.scalar_kind_for_type(ret_type, "call return")?;

        if ret_kind == dest_kind {
          writeln!(
            self.output,
            "    {} ={} {}",
            self.temp_name(function, dest_temp),
            ret_kind.abi(),
            call_text
          )
          .unwrap();
        } else {
          let tmp_name = format!("%qcall{}_{}", dest_temp.index(), ret_kind.abi());
          writeln!(self.output, "    {} ={} {}", tmp_name, ret_kind.abi(), call_text).unwrap();
          writeln!(
            self.output,
            "    {} ={} copy {}",
            self.temp_name(function, dest_temp),
            dest_kind.abi(),
            tmp_name
          )
          .unwrap();
        }
      },
      None => {
        writeln!(self.output, "    {}", call_text).unwrap();
      },
    }

    Ok(())
  }

  fn emit_terminator(
    &mut self,
    _def_id: DefinitionId,
    _function_name: &str,
    function: &FunctionLir,
    block_labels: &[String],
    terminator: &Terminator,
  ) -> Result<(), QbeError> {
    match terminator {
      Terminator::Goto(target) => {
        let target_label = block_labels
          .get(target.index() as usize)
          .ok_or_else(|| QbeError::unsupported_instruction(
            self.def_name(function.def_id),
            "terminator".to_string(),
            0,
            format!("invalid goto target block id {}", target.index()),
          ))?;

        writeln!(self.output, "    jmp @{}", target_label).unwrap();
      },
      Terminator::Branch {
        condition,
        then_block,
        else_block,
      } => {
        let condition_text = self.format_operand(function, condition, None, "branch condition")?;

        let then_label = block_labels
          .get(then_block.index() as usize)
          .ok_or_else(|| QbeError::unsupported_instruction(
            self.def_name(function.def_id),
            "terminator".to_string(),
            0,
            format!("invalid then block id {}", then_block.index()),
          ))?;

        let else_label = block_labels
          .get(else_block.index() as usize)
          .ok_or_else(|| QbeError::unsupported_instruction(
            self.def_name(function.def_id),
            "terminator".to_string(),
            0,
            format!("invalid else block id {}", else_block.index()),
          ))?;

        writeln!(
          self.output,
          "    jnz {}, @{}, @{}",
          condition_text,
          then_label,
          else_label
        )
        .unwrap();
      },
      Terminator::Return(value) => {
        if let Some(value) = value {
          let value_text = self.format_operand(function, value, None, "return")?;
          writeln!(self.output, "    ret {}", value_text).unwrap();
        } else {
          writeln!(self.output, "    ret").unwrap();
        }
      },
      Terminator::Unreachable => {
        writeln!(self.output, "    hlt").unwrap();
      },
    }

    Ok(())
  }

  fn arithmetic_opcode(
    &self,
    function: &FunctionLir,
    op: &BinaryOperation,
    left: &Operand,
  ) -> Result<&'static str, QbeError> {
    let left_type = self
      .operand_type(function, left)
      .ok_or_else(|| QbeError::unsupported_operand("binary operation", format!("{:?}", left)))?;

    let unsigned = self.is_unsigned_type(left_type);

    match op {
      BinaryOperation::Add => Ok("add"),
      BinaryOperation::Sub => Ok("sub"),
      BinaryOperation::Mul => Ok("mul"),
      BinaryOperation::Div => {
        if unsigned {
          Ok("udiv")
        } else {
          Ok("div")
        }
      },
      BinaryOperation::Mod => {
        if unsigned {
          Ok("urem")
        } else {
          Ok("rem")
        }
      },
      BinaryOperation::And | BinaryOperation::BitAnd => Ok("and"),
      BinaryOperation::Or | BinaryOperation::BitOr => Ok("or"),
      BinaryOperation::BitXor => Ok("xor"),
      BinaryOperation::BitShiftLeft => Ok("shl"),
      BinaryOperation::BitShiftRight => {
        if unsigned {
          Ok("shr")
        } else {
          Ok("sar")
        }
      },
      BinaryOperation::Pow => Err(QbeError::unsupported_instruction(
        "<unknown>".to_string(),
        "<unknown>".to_string(),
        0,
        "Pow operation".to_string(),
      )),
      BinaryOperation::Equal
      | BinaryOperation::NotEqual
      | BinaryOperation::LessThan
      | BinaryOperation::LessEqual
      | BinaryOperation::GreaterThan
      | BinaryOperation::GreaterEqual => Err(QbeError::unsupported_instruction(
        "<unknown>".to_string(),
        "<unknown>".to_string(),
        0,
        "comparison in arithmetic opcode".to_string(),
      )),
    }
  }

  fn compare_opcode_base(
    &self,
    function: &FunctionLir,
    op: &BinaryOperation,
    left: &Operand,
  ) -> Option<&'static str> {
    let left_type = self.operand_type(function, left)?;
    let unsigned = self.is_unsigned_type(left_type);

    match op {
      BinaryOperation::Equal => Some("ceq"),
      BinaryOperation::NotEqual => Some("cne"),
      BinaryOperation::LessThan => {
        if unsigned {
          Some("cult")
        } else {
          Some("cslt")
        }
      },
      BinaryOperation::LessEqual => {
        if unsigned {
          Some("cule")
        } else {
          Some("csle")
        }
      },
      BinaryOperation::GreaterThan => {
        if unsigned {
          Some("cugt")
        } else {
          Some("csgt")
        }
      },
      BinaryOperation::GreaterEqual => {
        if unsigned {
          Some("cuge")
        } else {
          Some("csge")
        }
      },
      _ => None,
    }
  }

  fn scalar_kind_for_temp(
    &self,
    function: &FunctionLir,
    temp: ignis_lir::TempId,
    context: &str,
  ) -> Result<ScalarKind, QbeError> {
    self.scalar_kind_for_type(function.temp_type(temp), context)
  }

  fn scalar_kind_for_operand(
    &self,
    function: &FunctionLir,
    operand: &Operand,
    context: &str,
  ) -> Result<ScalarKind, QbeError> {
    let ty = self
      .operand_type(function, operand)
      .ok_or_else(|| QbeError::unsupported_operand(context, format!("{:?}", operand)))?;

    self.scalar_kind_for_type(ty, context)
  }

  fn scalar_kind_for_type(
    &self,
    ty: TypeId,
    context: &str,
  ) -> Result<ScalarKind, QbeError> {
    match self.types.get(&ty) {
      Type::I8
      | Type::I16
      | Type::I32
      | Type::U8
      | Type::U16
      | Type::U32
      | Type::Boolean
      | Type::Char
      | Type::Atom => Ok(ScalarKind::W),

      Type::I64 | Type::U64 => Ok(ScalarKind::L),

      Type::Pointer { .. }
      | Type::Reference { .. }
      | Type::Str
      | Type::NullPtr
      | Type::Function { .. } => Ok(ScalarKind::L),

      Type::Void | Type::Never => Ok(ScalarKind::W),

      Type::Record(_)
      | Type::Enum(_)
      | Type::Tuple(_)
      | Type::Vector { .. } => Ok(ScalarKind::L),

      Type::F32 => Ok(ScalarKind::W),
      Type::F64 => Ok(ScalarKind::L),

      _ => Err(QbeError::unsupported_type(context, format!("{:?}", self.types.get(&ty)))),
    }
  }

  fn return_abi_for_type(
    &self,
    ty: TypeId,
  ) -> Result<Option<&'static str>, QbeError> {
    match self.types.get(&ty) {
      Type::Void | Type::Never => Ok(None),
      _ => Ok(Some(self.abi_for_type(ty, "function return")?)),
    }
  }

  fn abi_for_type(
    &self,
    ty: TypeId,
    context: &str,
  ) -> Result<&'static str, QbeError> {
    Ok(self.scalar_kind_for_type(ty, context)?.abi())
  }

  fn operand_type(
    &self,
    function: &FunctionLir,
    operand: &Operand,
  ) -> Option<TypeId> {
    match operand {
      Operand::Temp(temp) => Some(function.temp_type(*temp)),
      Operand::Local(local) => Some(function.local_type(*local)),
      Operand::Const(value) => Some(value.type_id()),
      Operand::FuncRef(_) | Operand::GlobalRef(_) => None,
    }
  }

  fn is_unsigned_type(
    &self,
    ty: TypeId,
  ) -> bool {
    matches!(
      self.types.get(&ty),
      Type::U8 | Type::U16 | Type::U32 | Type::U64 | Type::Boolean | Type::Char | Type::Atom
    )
  }

  fn format_operand(
    &mut self,
    function: &FunctionLir,
    operand: &Operand,
    _expected_kind: Option<ScalarKind>,
    context: &str,
  ) -> Result<String, QbeError> {
    match operand {
      Operand::Temp(temp) => Ok(self.temp_name(function, *temp)),
      Operand::Local(local) => Ok(format!("%l{}", local.index())),
      Operand::Const(value) => {
        let value = value.clone();
        self.format_const(&value, context)
      },
      Operand::FuncRef(def_id) | Operand::GlobalRef(def_id) => Ok(format!("${}", self.def_name(*def_id))),
    }
  }

  fn format_const(
    &mut self,
    value: &ConstValue,
    _context: &str,
  ) -> Result<String, QbeError> {
    match value {
      ConstValue::Int(value, _) => Ok(value.to_string()),
      ConstValue::UInt(value, _) => Ok(value.to_string()),
      ConstValue::Bool(value, _) => Ok(if *value { "1".to_string() } else { "0".to_string() }),
      ConstValue::Char(value, _) => Ok(value.to_string()),
      ConstValue::Atom(value, _) => Ok(value.to_string()),
      ConstValue::Null(_) => Ok("0".to_string()),
      ConstValue::Float(value, _) => {
        let float_val = value.into_inner();
        Ok(format!("d_{}", float_val.to_bits()))
      },
      ConstValue::String(value, _) => {
        let label = self.intern_string(value);
        Ok(format!("${}", label))
      },
      ConstValue::Undef(_) => Ok("0".to_string()),
    }
  }

  fn temp_name(
    &self,
    function: &FunctionLir,
    temp: ignis_lir::TempId,
  ) -> String {
    let index = temp.index();
    if (index as usize) < function.params.len() {
      format!("%p{}", index)
    } else {
      format!("%t{}", index)
    }
  }

  fn def_name(
    &self,
    def_id: DefinitionId,
  ) -> String {
    mangle_symbol_name(def_id, self.defs, self.namespaces, self.symbols, self.types)
  }

  fn compute_reachable_functions(&self) -> HashSet<DefinitionId> {
    let mut reachable = HashSet::new();
    let mut queue = VecDeque::new();

    if let Some(entry_id) = self.program.entry_point {
      reachable.insert(entry_id);
      queue.push_back(entry_id);
    }

    while let Some(current) = queue.pop_front() {
      let Some(function) = self.program.functions.get(&current) else {
        continue;
      };

      for (_, block) in function.blocks.iter() {
        for instruction in &block.instructions {
          match instruction {
            Instr::Call { callee, .. } => {
              if reachable.insert(*callee) {
                queue.push_back(*callee);
              }
            },
            Instr::MakeClosure { thunk, drop_fn, .. } => {
              if reachable.insert(*thunk) {
                queue.push_back(*thunk);
              }
              if let Some(drop_id) = drop_fn {
                if reachable.insert(*drop_id) {
                  queue.push_back(*drop_id);
                }
              }
            },
            Instr::RuntimeCall { name, .. } => {
              for (def_id, func) in &self.program.functions {
                if func.is_extern {
                  let def_name = self.symbols.get(&self.defs.get(def_id).name);
                  if def_name == name.as_str() {
                    reachable.insert(*def_id);
                  }
                }
              }
            },
            _ => {},
          }
        }
      }
    }

    reachable
  }

  fn is_function_signature_monomorphized(
    &self,
    func: &FunctionLir,
  ) -> bool {
    if !self.is_fully_monomorphized(func.return_type) {
      return false;
    }

    for &param_def_id in &func.params {
      let param_type = *self.defs.type_of(&param_def_id);
      if !self.is_fully_monomorphized(param_type) {
        return false;
      }
    }

    true
  }

  fn is_fully_monomorphized(
    &self,
    type_id: TypeId,
  ) -> bool {
    match self.types.get(&type_id) {
      Type::Param { .. } | Type::Instance { .. } | Type::Infer => false,
      Type::Pointer { inner, .. } | Type::Reference { inner, .. } => self.is_fully_monomorphized(*inner),
      Type::Vector { element, .. } => self.is_fully_monomorphized(*element),
      Type::Function { params, ret, .. } => {
        params.iter().all(|&p| self.is_fully_monomorphized(p)) && self.is_fully_monomorphized(*ret)
      },
      _ => true,
    }
  }

  fn fresh_aux_tmp(&mut self) -> String {
    let id = self.next_aux_tmp;
    self.next_aux_tmp += 1;
    format!("%qaux_{}", id)
  }

  fn record_has_drop_trait(
    &self,
    def_id: DefinitionId,
  ) -> bool {
    let def = self.defs.get(&def_id);
    match &def.kind {
      DefinitionKind::Record(rd) => rd.lang_traits.drop,
      DefinitionKind::Enum(ed) => ed.lang_traits.drop,
      _ => false,
    }
  }

  fn find_drop_method(
    &self,
    def_id: DefinitionId,
  ) -> Option<DefinitionId> {
    let def = self.defs.get(&def_id);

    let (instance_methods, has_drop) = match &def.kind {
      DefinitionKind::Record(rd) => (&rd.instance_methods, rd.lang_traits.drop),
      DefinitionKind::Enum(ed) => (&ed.instance_methods, ed.lang_traits.drop),
      _ => return None,
    };

    for (sym_id, entry) in instance_methods {
      if self.symbols.get(sym_id) == "drop" {
        return match entry {
          ignis_type::definition::SymbolEntry::Single(id) => Some(*id),
          ignis_type::definition::SymbolEntry::Overload(ids) => ids.first().copied(),
        };
      }
    }

    if has_drop && instance_methods.is_empty() {
      for (method_def_id, method_def) in self.defs.iter() {
        if let DefinitionKind::Method(md) = &method_def.kind
          && md.owner_type == def_id
        {
          let method_name = self.symbols.get(&method_def.name);
          if method_name == "drop" || method_name.ends_with("__drop") {
            return Some(method_def_id);
          }
        }
      }
    }

    None
  }

  fn emit_field_drops_qbe(
    &mut self,
    ptr_expr: &str,
    ty: TypeId,
  ) -> Result<(), QbeError> {
    match self.types.get(&ty).clone() {
      Type::Record(def_id) => {
        if let Some(method_def_id) = self.find_drop_method(def_id) {
          let name = self.def_name(method_def_id);
          writeln!(self.output, "    call ${}(l {})", name, ptr_expr).unwrap();
        } else {
          let field_info: Vec<(u32, TypeId)> = {
            let def = self.defs.get(&def_id);
            match &def.kind {
              DefinitionKind::Record(rd) => rd.fields.iter().map(|f| (f.index, f.type_id)).collect(),
              _ => vec![],
            }
          };

          for (index, field_ty) in field_info {
            if self.types.needs_drop_with_defs(&field_ty, self.defs) {
              let offset = self.field_offset(ty, index);
              let field_ptr = self.fresh_aux_tmp();

              if offset == 0 {
                writeln!(self.output, "    {} =l copy {}", field_ptr, ptr_expr).unwrap();
              } else {
                writeln!(self.output, "    {} =l add {}, {}", field_ptr, ptr_expr, offset).unwrap();
              }

              self.emit_field_drops_qbe(&field_ptr, field_ty)?;
            }
          }
        }
      },

      Type::Enum(def_id) => {
        if let Some(method_def_id) = self.find_drop_method(def_id) {
          let name = self.def_name(method_def_id);
          writeln!(self.output, "    call ${}(l {})", name, ptr_expr).unwrap();
        } else {
          writeln!(self.output, "    # enum drop: variant dispatch not yet implemented").unwrap();
        }
      },

      _ => {
        writeln!(self.output, "    # drop: non-droppable type").unwrap();
      },
    }

    Ok(())
  }

  fn drop_glue_name(
    &self,
    ty: TypeId,
  ) -> String {
    format!("ignis_drop_glue_{}", ty.index())
  }

  fn emit_drop_glue_functions(&mut self) -> Result<(), QbeError> {
    let mut glue_types = std::mem::take(&mut self.drop_glue_types);
    glue_types.sort_by_key(|ty| ty.index());
    glue_types.dedup();

    for ty in glue_types {
      writeln!(self.output).unwrap();
      self.emit_drop_glue_function(ty)?;
    }

    Ok(())
  }

  fn emit_drop_glue_function(
    &mut self,
    ty: TypeId,
  ) -> Result<(), QbeError> {
    let helper_name = self.drop_glue_name(ty);

    writeln!(self.output, "function ${}(l %payload) {{", helper_name).unwrap();
    writeln!(self.output, "@start").unwrap();

    if self.types.needs_drop_with_defs(&ty, self.defs) {
      self.emit_field_drops_qbe("%payload", ty)?;
    }

    writeln!(self.output, "    ret").unwrap();
    writeln!(self.output, "}}").unwrap();

    Ok(())
  }

  fn emit_make_closure(
    &mut self,
    function: &FunctionLir,
    dest: ignis_lir::TempId,
    thunk: DefinitionId,
    drop_fn: Option<DefinitionId>,
    captures: &[Operand],
    heap_allocate: bool,
  ) -> Result<(), QbeError> {
    let thunk_name = self.def_name(thunk);
    let drop_fn_ptr = match drop_fn {
      Some(drop_id) => format!("${}", self.def_name(drop_id)),
      None => "0".to_string(),
    };

    let env_size = (captures.len() as u64) * 8;

    let env_ptr = if captures.is_empty() {
      "0".to_string()
    } else if heap_allocate {
      let malloc_tmp = self.fresh_aux_tmp();
      writeln!(self.output, "    {} =l call $malloc(l {})", malloc_tmp, env_size).unwrap();

      for (i, cap_op) in captures.iter().enumerate() {
        let cap_kind = self
          .operand_type(function, cap_op)
          .and_then(|ty| self.scalar_kind_for_type(ty, "closure capture").ok())
          .unwrap_or(ScalarKind::L);
        let cap_text = self.format_operand(function, cap_op, Some(cap_kind), "closure capture")?;
        let offset = (i as u64) * 8;

        if offset == 0 {
          writeln!(self.output, "    {} {}, {}", cap_kind.store_op(), cap_text, malloc_tmp).unwrap();
        } else {
          let field_ptr = self.fresh_aux_tmp();
          writeln!(self.output, "    {} =l add {}, {}", field_ptr, malloc_tmp, offset).unwrap();
          writeln!(self.output, "    {} {}, {}", cap_kind.store_op(), cap_text, field_ptr).unwrap();
        }
      }

      malloc_tmp
    } else {
      let env_alloc = self.fresh_aux_tmp();
      writeln!(self.output, "    {} =l alloc8 {}", env_alloc, env_size).unwrap();

      for (i, cap_op) in captures.iter().enumerate() {
        let cap_kind = self
          .operand_type(function, cap_op)
          .and_then(|ty| self.scalar_kind_for_type(ty, "closure capture").ok())
          .unwrap_or(ScalarKind::L);
        let cap_text = self.format_operand(function, cap_op, Some(cap_kind), "closure capture")?;
        let offset = (i as u64) * 8;

        if offset == 0 {
          writeln!(self.output, "    {} {}, {}", cap_kind.store_op(), cap_text, env_alloc).unwrap();
        } else {
          let field_ptr = self.fresh_aux_tmp();
          writeln!(self.output, "    {} =l add {}, {}", field_ptr, env_alloc, offset).unwrap();
          writeln!(self.output, "    {} {}, {}", cap_kind.store_op(), cap_text, field_ptr).unwrap();
        }
      }

      env_alloc
    };

    let closure_alloc = self.fresh_aux_tmp();
    writeln!(self.output, "    {} =l alloc8 24", closure_alloc).unwrap();

    writeln!(self.output, "    storel ${}, {}", thunk_name, closure_alloc).unwrap();

    let drop_slot = self.fresh_aux_tmp();
    writeln!(self.output, "    {} =l add {}, 8", drop_slot, closure_alloc).unwrap();
    writeln!(self.output, "    storel {}, {}", drop_fn_ptr, drop_slot).unwrap();

    let env_slot = self.fresh_aux_tmp();
    writeln!(self.output, "    {} =l add {}, 16", env_slot, closure_alloc).unwrap();
    writeln!(self.output, "    storel {}, {}", env_ptr, env_slot).unwrap();

    writeln!(
      self.output,
      "    {} =l copy {}",
      self.temp_name(function, dest),
      closure_alloc
    )
    .unwrap();

    Ok(())
  }

  fn emit_call_closure(
    &mut self,
    function: &FunctionLir,
    dest: Option<ignis_lir::TempId>,
    closure: &Operand,
    args: &[Operand],
    return_type: TypeId,
  ) -> Result<(), QbeError> {
    let closure_text = self.format_operand(function, closure, Some(ScalarKind::L), "callclosure")?;

    let call_fn_ptr = self.fresh_aux_tmp();
    writeln!(self.output, "    {} =l loadl {}", call_fn_ptr, closure_text).unwrap();

    let env_slot = self.fresh_aux_tmp();
    writeln!(self.output, "    {} =l add {}, 16", env_slot, closure_text).unwrap();
    let env_ptr = self.fresh_aux_tmp();
    writeln!(self.output, "    {} =l loadl {}", env_ptr, env_slot).unwrap();

    let mut arg_texts = vec![format!("l {}", env_ptr)];
    for arg in args {
      let kind = self
        .operand_type(function, arg)
        .and_then(|ty| self.scalar_kind_for_type(ty, "callclosure arg").ok())
        .unwrap_or(ScalarKind::L);
      let value_text = self.format_operand(function, arg, Some(kind), "callclosure arg")?;
      arg_texts.push(format!("{} {}", kind.abi(), value_text));
    }

    let call_text = format!("call {}({})", call_fn_ptr, arg_texts.join(", "));

    match dest {
      Some(dest_temp) => {
        let ret_kind = self.scalar_kind_for_type(return_type, "callclosure return").unwrap_or(ScalarKind::L);
        writeln!(
          self.output,
          "    {} ={} {}",
          self.temp_name(function, dest_temp),
          ret_kind.abi(),
          call_text
        )
        .unwrap();
      },
      None => {
        writeln!(self.output, "    {}", call_text).unwrap();
      },
    }

    Ok(())
  }

  fn emit_drop_closure(
    &mut self,
    function: &FunctionLir,
    closure: &Operand,
    heap_allocated: bool,
  ) -> Result<(), QbeError> {
    let closure_text = self.format_operand(function, closure, Some(ScalarKind::L), "dropclosure")?;

    let drop_slot = self.fresh_aux_tmp();
    writeln!(self.output, "    {} =l add {}, 8", drop_slot, closure_text).unwrap();
    let drop_fn_ptr = self.fresh_aux_tmp();
    writeln!(self.output, "    {} =l loadl {}", drop_fn_ptr, drop_slot).unwrap();

    let env_slot = self.fresh_aux_tmp();
    writeln!(self.output, "    {} =l add {}, 16", env_slot, closure_text).unwrap();
    let env_ptr = self.fresh_aux_tmp();
    writeln!(self.output, "    {} =l loadl {}", env_ptr, env_slot).unwrap();

    let has_drop_label = format!("qdc_has_drop_{}", self.next_aux_tmp);
    let done_label = format!("qdc_done_{}", self.next_aux_tmp);
    self.next_aux_tmp += 1;

    writeln!(self.output, "    jnz {}, @{}, @{}", drop_fn_ptr, has_drop_label, done_label).unwrap();

    writeln!(self.output, "@{}", has_drop_label).unwrap();
    writeln!(self.output, "    call {}(l {})", drop_fn_ptr, env_ptr).unwrap();

    if heap_allocated {
      let has_env_label = format!("qdc_has_env_{}", self.next_aux_tmp);
      let free_done_label = format!("qdc_free_done_{}", self.next_aux_tmp);
      self.next_aux_tmp += 1;

      writeln!(self.output, "    jnz {}, @{}, @{}", env_ptr, has_env_label, free_done_label).unwrap();

      writeln!(self.output, "@{}", has_env_label).unwrap();
      writeln!(self.output, "    call $free(l {})", env_ptr).unwrap();
      writeln!(self.output, "    jmp @{}", free_done_label).unwrap();

      writeln!(self.output, "@{}", free_done_label).unwrap();
    }

    writeln!(self.output, "    jmp @{}", done_label).unwrap();
    writeln!(self.output, "@{}", done_label).unwrap();

    Ok(())
  }

  fn intern_string(
    &mut self,
    value: &str,
  ) -> String {
    for (label, existing) in &self.string_literals {
      if existing == value {
        return label.clone();
      }
    }

    let label = format!("__qstr_{}", self.next_string_id);
    self.next_string_id += 1;
    self.string_literals.push((label.clone(), value.to_string()));
    label
  }

  fn sizeof_type(
    &mut self,
    ty: TypeId,
  ) -> u64 {
    if let Some(&cached) = self.type_sizes.get(&ty) {
      return cached;
    }

    let size = self.compute_sizeof(ty);
    self.type_sizes.insert(ty, size);
    size
  }

  fn compute_sizeof(
    &mut self,
    ty: TypeId,
  ) -> u64 {
    match self.types.get(&ty).clone() {
      Type::Boolean | Type::I8 | Type::U8 | Type::Char => 1,
      Type::I16 | Type::U16 => 2,
      Type::I32 | Type::U32 | Type::Atom => 4,
      Type::I64 | Type::U64 => 8,
      Type::F32 => 4,
      Type::F64 => 8,

      Type::Pointer { .. }
      | Type::Reference { .. }
      | Type::Str
      | Type::NullPtr
      | Type::Function { .. } => 8,

      Type::Void | Type::Never => 0,

      Type::Record(def_id) => {
        let fields: Vec<(u32, TypeId)> = {
          let def = self.defs.get(&def_id);
          match &def.kind {
            DefinitionKind::Record(rd) => rd.fields.iter().map(|f| (f.index, f.type_id)).collect(),
            _ => return 0,
          }
        };

        if fields.is_empty() {
          return 0;
        }

        let mut total: u64 = 0;
        for (_idx, field_ty) in &fields {
          let field_size = self.sizeof_type(*field_ty);
          let field_align = self.alignof_type(*field_ty);
          let padding = (field_align - (total % field_align)) % field_align;
          total += padding + field_size;
        }

        let struct_align = self.alignof_record_type(ty);
        let tail_padding = (struct_align - (total % struct_align)) % struct_align;
        total + tail_padding
      },

      Type::Enum(def_id) => {
        let variants: Vec<Vec<TypeId>> = {
          let def = self.defs.get(&def_id);
          match &def.kind {
            DefinitionKind::Enum(ed) => ed.variants.iter().map(|v| v.payload.clone()).collect(),
            _ => return 4,
          }
        };

        let tag_size: u64 = 4;
        let mut max_payload_size: u64 = 0;

        for payload_types in &variants {
          let mut variant_size: u64 = 0;
          for payload_ty in payload_types {
            let field_size = self.sizeof_type(*payload_ty);
            let field_align = self.alignof_type(*payload_ty);
            let padding = (field_align - (variant_size % field_align)) % field_align;
            variant_size += padding + field_size;
          }
          max_payload_size = max_payload_size.max(variant_size);
        }

        let payload_align: u64 = 8;
        let payload_offset = tag_size + ((payload_align - (tag_size % payload_align)) % payload_align);
        let total = payload_offset + max_payload_size;

        let struct_align: u64 = 8;
        total + ((struct_align - (total % struct_align)) % struct_align)
      },

      Type::Vector { element, size } => {
        let elem_size = self.sizeof_type(element);
        elem_size * (size as u64)
      },

      Type::Tuple(ref fields) => {
        let fields = fields.clone();
        let mut total: u64 = 0;
        for field_ty in &fields {
          let field_size = self.sizeof_type(*field_ty);
          let field_align = self.alignof_type(*field_ty);
          let padding = (field_align - (total % field_align)) % field_align;
          total += padding + field_size;
        }

        if total == 0 {
          return 0;
        }

        let struct_align = fields
          .iter()
          .map(|f| self.alignof_type(*f))
          .max()
          .unwrap_or(1);
        total + ((struct_align - (total % struct_align)) % struct_align)
      },

      _ => 8,
    }
  }

  fn alignof_type(
    &mut self,
    ty: TypeId,
  ) -> u64 {
    match self.types.get(&ty).clone() {
      Type::Boolean | Type::I8 | Type::U8 | Type::Char => 1,
      Type::I16 | Type::U16 => 2,
      Type::I32 | Type::U32 | Type::Atom | Type::F32 => 4,
      Type::I64 | Type::U64 | Type::F64 => 8,

      Type::Pointer { .. }
      | Type::Reference { .. }
      | Type::Str
      | Type::NullPtr
      | Type::Function { .. } => 8,

      Type::Void | Type::Never => 1,

      Type::Record(_) | Type::Enum(_) => self.alignof_record_type(ty),

      Type::Vector { element, .. } => self.alignof_type(element),

      Type::Tuple(ref fields) => {
        let fields = fields.clone();
        fields.iter().map(|f| self.alignof_type(*f)).max().unwrap_or(1)
      },

      _ => 8,
    }
  }

  fn alignof_record_type(
    &mut self,
    ty: TypeId,
  ) -> u64 {
    match self.types.get(&ty).clone() {
      Type::Record(def_id) => {
        let field_types: Vec<TypeId> = {
          let def = self.defs.get(&def_id);
          match &def.kind {
            DefinitionKind::Record(rd) => rd.fields.iter().map(|f| f.type_id).collect(),
            _ => return 8,
          }
        };

        field_types
          .iter()
          .map(|f| self.alignof_type(*f))
          .max()
          .unwrap_or(1)
      },
      Type::Enum(_) => 8,
      _ => 8,
    }
  }

  fn field_offset(
    &mut self,
    record_type: TypeId,
    field_index: u32,
  ) -> u64 {
    let field_types: Vec<(u32, TypeId)> = match self.types.get(&record_type).clone() {
      Type::Record(def_id) => {
        let def = self.defs.get(&def_id);
        match &def.kind {
          DefinitionKind::Record(rd) => rd.fields.iter().map(|f| (f.index, f.type_id)).collect(),
          _ => return (field_index as u64) * 8,
        }
      },
      _ => return (field_index as u64) * 8,
    };

    let mut offset: u64 = 0;
    for (idx, field_ty) in &field_types {
      let field_align = self.alignof_type(*field_ty);
      let padding = (field_align - (offset % field_align)) % field_align;
      offset += padding;

      if *idx == field_index {
        return offset;
      }

      offset += self.sizeof_type(*field_ty);
    }

    offset
  }

  fn record_field_type(
    &self,
    record_type: TypeId,
    field_index: u32,
  ) -> Option<TypeId> {
    match self.types.get(&record_type) {
      Type::Record(def_id) => {
        let def = self.defs.get(def_id);
        match &def.kind {
          DefinitionKind::Record(rd) => rd.fields.iter().find(|f| f.index == field_index).map(|f| f.type_id),
          _ => None,
        }
      },
      _ => None,
    }
  }

  fn enum_payload_offset(
    &mut self,
    _enum_type: TypeId,
  ) -> u64 {
    let tag_size: u64 = 4;
    let payload_align: u64 = 8;
    tag_size + ((payload_align - (tag_size % payload_align)) % payload_align)
  }

  fn type_max_value(
    &self,
    ty: TypeId,
  ) -> String {
    match self.types.get(&ty) {
      Type::I8 => "127".to_string(),
      Type::I16 => "32767".to_string(),
      Type::I32 => "2147483647".to_string(),
      Type::I64 => "9223372036854775807".to_string(),
      Type::U8 => "255".to_string(),
      Type::U16 => "65535".to_string(),
      Type::U32 => "4294967295".to_string(),
      Type::U64 => "18446744073709551615".to_string(),
      Type::Boolean => "1".to_string(),
      Type::Char => "255".to_string(),
      _ => "0".to_string(),
    }
  }

  fn type_min_value(
    &self,
    ty: TypeId,
  ) -> String {
    match self.types.get(&ty) {
      Type::I8 => "-128".to_string(),
      Type::I16 => "-32768".to_string(),
      Type::I32 => "-2147483648".to_string(),
      Type::I64 => "-9223372036854775808".to_string(),
      Type::U8 | Type::U16 | Type::U32 | Type::U64 | Type::Boolean | Type::Char => "0".to_string(),
      _ => "0".to_string(),
    }
  }
}

fn qbe_escape_string(s: &str) -> String {
  let mut out = String::with_capacity(s.len());

  for byte in s.bytes() {
    match byte {
      b'\\' => out.push_str("\\\\"),
      b'"' => out.push_str("\\\""),
      b'\n' => out.push_str("\\n"),
      b'\r' => out.push_str("\\r"),
      b'\t' => out.push_str("\\t"),
      b'\0' => out.push_str("\\0"),
      0x20..=0x7e => out.push(byte as char),
      _ => {
        out.push_str(&format!("\\x{:02x}", byte));
      },
    }
  }

  out
}

fn sanitize_label(label: &str) -> String {
  let mut out = String::with_capacity(label.len());

  for character in label.chars() {
    if character.is_ascii_alphanumeric() || character == '_' {
      out.push(character);
    } else {
      out.push('_');
    }
  }

  if out.is_empty() {
    return "block".to_string();
  }

  if out.chars().next().is_some_and(|first| first.is_ascii_digit()) {
    out.insert(0, 'b');
  }

  out
}
